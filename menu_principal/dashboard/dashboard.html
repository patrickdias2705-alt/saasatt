<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="https://imagens-zipline.hgabnb.easypanel.host/u/2FsJTY.png">
    <link rel="shortcut icon" type="image/png" href="https://imagens-zipline.hgabnb.easypanel.host/u/2FsJTY.png">
    <link rel="apple-touch-icon" href="https://imagens-zipline.hgabnb.easypanel.host/u/2FsJTY.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Métricas - Salesdever</title>
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Raleway', sans-serif;
        }

        body {
            background: #0a0420;
            min-height: 100vh;
            color: #ffffff;
            padding: 2rem;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at 20% 50%, rgba(165, 148, 255, 0.08) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(102, 126, 234, 0.06) 0%, transparent 50%);
            animation: backgroundFloat 20s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(3%, 3%); }
        }

        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .dashboard-header {
            margin-bottom: 2rem;
            animation: fadeInDown 0.6s ease;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 2rem;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dashboard-title {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #ffffff, #A594FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dashboard-subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }

        .filters-section {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.12), rgba(102, 126, 234, 0.08));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(165, 148, 255, 0.3);
            border-radius: 1.5rem;
            padding: 2rem;
            margin-bottom: 2.5rem;
            display: grid;
            grid-template-columns: 1fr 2fr auto;
            gap: 2rem;
            align-items: end;
            box-shadow: 0 8px 32px rgba(165, 148, 255, 0.15);
            animation: fadeInUp 0.6s ease 0.1s both;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .filter-label {
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
        }

        .filter-select {
            padding: 1rem 1.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(165, 148, 255, 0.3);
            border-radius: 1rem;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%23A594FF' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            padding-right: 3rem;
        }

        .filter-select:hover {
            border-color: rgba(165, 148, 255, 0.6);
            transform: translateY(-2px);
        }

        .filter-select:focus {
            outline: none;
            border-color: #A594FF;
            box-shadow: 0 0 0 4px rgba(165, 148, 255, 0.2);
        }

        .apply-filters-btn {
            padding: 1rem 2.5rem;
            background: linear-gradient(135deg,
                        #667eea 0%,
                        #8b7abd 35%,
                        #A594FF 70%,
                        #b8a9ff 100%);
            border: 1px solid rgba(165, 148, 255, 0.5);
            border-radius: 1rem;
            color: white;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(165, 148, 255, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.15);
            position: relative;
        }

        .apply-filters-btn:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg,
                        #7a8def 0%,
                        #9d8bc8 35%,
                        #b5a4ff 70%,
                        #c9baff 100%);
            box-shadow: 0 8px 30px rgba(165, 148, 255, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.25);
            border-color: rgba(165, 148, 255, 0.7);
        }

        .apply-filters-btn.loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .apply-filters-btn.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .kpis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2.5rem;
        }

        .kpi-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            padding: 1.25rem;
            transition: all 0.4s ease;
            animation: fadeInUp 0.6s ease both;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .kpi-card:nth-child(1) { animation-delay: 0.1s; }
        .kpi-card:nth-child(2) { animation-delay: 0.2s; }
        .kpi-card:nth-child(3) { animation-delay: 0.3s; }
        .kpi-card:nth-child(4) { animation-delay: 0.4s; }
        .kpi-card:nth-child(5) { animation-delay: 0.5s; }

        /* CARD GRANDE COM GRÁFICO - OCUPA 2 COLUNAS */
        .kpi-card.with-chart {
            grid-column: span 2;
        }

        /* WIDGET GRAZI - COMPACTO (1 COLUNA) */
        .grazi-widget {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.15), rgba(102, 126, 234, 0.1));
            border: 1px solid rgba(165, 148, 255, 0.3);
        }
        
        .grazi-widget-compact {
            grid-column: span 1;
        }

        .grazi-widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.2);
        }
        
        .grazi-widget-compact .grazi-widget-header {
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
        }

        .grazi-widget-title-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .grazi-widget-avatar {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px solid rgba(165, 148, 255, 0.4);
            object-fit: cover;
        }
        
        .grazi-widget-compact .grazi-widget-avatar {
            width: 40px;
            height: 40px;
        }

        .grazi-widget-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .grazi-widget-title span:first-child {
            background: linear-gradient(135deg, #ffffff, #A594FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .grazi-ai-badge {
            background: linear-gradient(135deg, #A594FF, #667EEA);
            color: white;
            padding: 0.25rem 0.625rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(165, 148, 255, 0.3);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .grazi-widget-compact .grazi-widget-title {
            font-size: 1.125rem;
        }
        
        .grazi-widget-compact .grazi-ai-badge {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
        }
        
        .grazi-ai-badge-popup {
            background: linear-gradient(135deg, #A594FF, #667EEA);
            color: white;
            padding: 0.35rem 0.75rem;
            border-radius: 10px;
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(165, 148, 255, 0.3);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 0.5rem;
        }

        .grazi-widget-subtitle {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.6);
            margin: 0.25rem 0 0 0;
        }

        .grazi-widget-more-btn {
            background: rgba(165, 148, 255, 0.2);
            border: 1px solid rgba(165, 148, 255, 0.4);
            color: #A594FF;
            padding: 0.625rem 1.25rem;
            border-radius: 10px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            font-family: 'Raleway', sans-serif;
        }

        .grazi-widget-more-btn:hover {
            background: rgba(165, 148, 255, 0.3);
            border-color: rgba(165, 148, 255, 0.6);
            transform: translateX(4px);
        }

        .grazi-widget-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .grazi-widget-compact .grazi-widget-content {
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        .grazi-widget-section {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(165, 148, 255, 0.15);
            border-radius: 12px;
            padding: 1.25rem;
            transition: all 0.3s ease;
        }
        
        .grazi-widget-compact .grazi-widget-section {
            padding: 0.875rem;
        }

        /* WIDGET GRAZI - FORMATO ESTICADO (OCUPA MAIS ESPAÇO) */
        .grazi-widget-stretched {
            /* Usa o mesmo fundo dos outros KPIs (padronizado) */
            grid-column: span 2;
            padding: 0.75rem 0.875rem;
            overflow: visible !important;
        }
        
        .grazi-widget-header-custom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .grazi-name-mini {
            background: linear-gradient(135deg, #ffffff, #A594FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .grazi-ai-badge-mini {
            background: linear-gradient(135deg, #A594FF, #667EEA);
            color: white;
            padding: 0.1rem 0.3rem;
            border-radius: 5px;
            font-size: 0.625rem;
            font-weight: 600;
            letter-spacing: 0.2px;
            box-shadow: 0 1px 3px rgba(165, 148, 255, 0.3);
            display: inline-flex;
            align-items: center;
            margin-left: 0.2rem;
        }
        
        .grazi-widget-preview {
            font-size: 0.8125rem;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.5;
            margin-top: 0.5rem;
            margin-bottom: 0.75rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            min-height: 2.5rem;
        }
        
        /* LAYOUT EM SEÇÕES PARA GRAZI */
        .grazi-widget-sections {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.4rem;
            margin-top: 0.5rem;
            overflow: visible;
        }

        .grazi-section-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.625rem;
            overflow: visible;
        }
        
        .grazi-header-with-avatar {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .grazi-widget-avatar-small {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1.5px solid rgba(165, 148, 255, 0.4);
            object-fit: cover;
            flex-shrink: 0;
        }
        
        .grazi-section-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.4rem;
        }
        
        .grazi-section-item {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 12px;
            padding: 0.75rem 0.875rem;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 0;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            overflow: visible;
            min-height: 42px;
        }

        .grazi-section-item:hover {
            border-color: rgba(165, 148, 255, 0.4);
            z-index: 100;
        }

        /* Caixas da direita (Ligações e Agendamentos) afastadas da borda */
        .grazi-section-row .grazi-section-item:nth-child(2) {
            margin-right: 1.25rem !important;
        }

        /* Tooltip para texto completo */
        .grazi-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: rgba(20, 20, 35, 0.98);
            border: 1px solid rgba(165, 148, 255, 0.4);
            border-radius: 8px;
            padding: 0.75rem;
            min-width: 200px;
            max-width: 280px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
            white-space: normal;
        }

        .grazi-section-item:hover .grazi-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .grazi-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(165, 148, 255, 0.4);
        }

        .grazi-tooltip-title {
            font-size: 0.6875rem;
            font-weight: 600;
            color: #A594FF;
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .grazi-tooltip-text {
            font-size: 0.625rem;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
        }
        
        .grazi-section-header {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            margin-bottom: 0;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .grazi-section-icon {
            width: 14px;
            height: 14px;
            color: #A594FF;
            flex-shrink: 0;
        }

        .grazi-section-title {
            font-size: 0.6875rem !important;
            font-weight: 600;
            color: #A594FF;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .grazi-section-title::after {
            content: ': ';
        }

        .grazi-section-text {
            font-size: 0.625rem !important;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
            min-width: 0;
        }
        
        
        .grazi-widget-more-btn-top {
            background: rgba(165, 148, 255, 0.15);
            border: 1px solid rgba(165, 148, 255, 0.3);
            color: #A594FF;
            padding: 0.3rem 0.625rem;
            border-radius: 5px;
            font-size: 0.5625rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Raleway', sans-serif;
            flex-shrink: 0;
        }

        .grazi-widget-more-btn-top:hover {
            background: rgba(165, 148, 255, 0.25);
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-2px);
        }

        .grazi-widget-section:hover {
            border-color: rgba(165, 148, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
        }

        .grazi-widget-section-title {
            font-size: 1rem;
            font-weight: 600;
            color: #A594FF;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .grazi-widget-compact .grazi-widget-section-title {
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .grazi-widget-section-title svg {
            width: 18px;
            height: 18px;
        }

        .grazi-widget-section-content {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
        }
        
        .grazi-widget-compact .grazi-widget-section-content {
            font-size: 0.8125rem;
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .grazi-widget-loading {
            padding: 0.25rem 0;
        }

        @media (max-width: 1024px) {
            .grazi-widget {
                grid-column: span 1;
            }
            
            .grazi-widget-content {
                grid-template-columns: 1fr;
            }
        }

        .kpi-card:hover {
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-6px);
            box-shadow: 0 15px 40px rgba(165, 148, 255, 0.25);
        }

        .kpi-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .kpi-icon {
            width: 40px;
            height: 40px;
            border-radius: 0.875rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .kpi-icon.purple { 
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.3), rgba(165, 148, 255, 0.15));
        }
        .kpi-icon.green { 
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3), rgba(34, 197, 94, 0.15));
        }
        .kpi-icon.blue { 
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.15));
        }
        .kpi-icon.orange { 
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.3), rgba(251, 146, 60, 0.15));
        }

        .kpi-label {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.85);
            font-weight: 600;
        }

        /* LAYOUT HORIZONTAL PARA CARD COM GRÁFICO */
        .kpi-content {
            display: flex;
            gap: 2rem;
            align-items: flex-end;
            position: relative;
            z-index: 1;
        }

        .kpi-stats {
            flex: 0 0 auto;
        }

        .kpi-chart-container {
            flex: 1;
            min-width: 0;
            position: relative;
        }

        .kpi-value {
            font-size: 2.25rem;
            font-weight: 800;
            color: #ffffff;
            margin-bottom: 0.75rem;
            line-height: 1;
        }

        .kpi-change {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9375rem;
            font-weight: 600;
        }

        .kpi-change.positive { color: rgba(134, 239, 172, 0.6); }
        .kpi-change.negative { color: rgba(239, 68, 68, 0.6); }
        .kpi-change.neutral { color: rgba(255, 255, 255, 0.5); }

        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 100px;
        }

        .chart-wrapper canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .chart-tooltip {
            position: fixed;
            background: rgba(15, 10, 35, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(165, 148, 255, 0.5);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .chart-tooltip.visible {
            opacity: 1;
        }

        .tooltip-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #A594FF;
            margin-bottom: 0.25rem;
        }

        .tooltip-date {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .skeleton {
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.05) 0%, 
                rgba(255, 255, 255, 0.12) 50%, 
                rgba(255, 255, 255, 0.05) 100%
            );
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 0.5rem;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-number { height: 2.5rem; width: 70%; margin-bottom: 0.5rem; }
        .skeleton-small { height: 1rem; width: 60%; }
        .skeleton-chart { height: 100px; width: 100%; }

        .metrics-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
            gap: 1.5rem;
        }

        .metric-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
            animation: fadeInUp 0.6s ease both;
        }

        .metric-card:hover {
            border-color: rgba(165, 148, 255, 0.3);
            transform: translateY(-4px);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-title {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .metric-badge {
            padding: 0.5rem 1rem;
            background: rgba(165, 148, 255, 0.2);
            border: 1px solid rgba(165, 148, 255, 0.4);
            border-radius: 0.75rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: #A594FF;
        }

        .metrics-list {
            display: grid;
            gap: 1rem;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            transition: all 0.2s ease;
        }

        .metric-item:hover {
            background: rgba(255, 255, 255, 0.07);
            transform: translateX(4px);
        }

        .metric-item-label {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.85);
        }

        .metric-item-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #A594FF;
        }

        .progress-bar-container {
            margin-top: 0.75rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #A594FF, #667eea);
            border-radius: 4px;
            transition: width 0.8s ease;
        }

        .progress-bar-fill.green {
            background: linear-gradient(90deg, #22C55E, #16A34A);
        }

        .progress-bar-fill.red {
            background: linear-gradient(90deg, #EF4444, #DC2626);
        }

        .error-message {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 4rem 2rem;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
        }

        .empty-state-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 1.5rem;
            opacity: 0.4;
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
        }

        @media (max-width: 1024px) {
            .filters-section { grid-template-columns: 1fr; }
            .metrics-section { grid-template-columns: 1fr; }
            .grazi-widget-stretched { grid-column: span 1 !important; }
            .kpi-card.with-chart { grid-column: span 1 !important; }
            .kpi-card.with-chart { grid-column: span 1; }
            
            .grazi-section-row {
                grid-template-columns: 1fr !important;
            }
        }

        @media (max-width: 768px) {
            .kpi-content {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }
        }

        /* ============================================
           POPUP IA INSIGHTS
           ============================================ */

        .insights-btn {
            padding: 1rem 78px 1rem 2rem;
            background: linear-gradient(135deg,
                        rgba(165, 148, 255, 0.08) 0%,
                        rgba(102, 126, 234, 0.05) 50%,
                        rgba(165, 148, 255, 0.03) 100%);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(165, 148, 255, 0.3);
            border-radius: 1rem;
            color: white;
            font-weight: 700;
            font-size: 1.05rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            flex-shrink: 0;
            position: relative;
            overflow: visible;
            box-shadow: 0 4px 15px rgba(165, 148, 255, 0.15);
            letter-spacing: 0.3px;
        }


        .insights-btn:hover {
            background: linear-gradient(135deg,
                        rgba(165, 148, 255, 0.15) 0%,
                        rgba(102, 126, 234, 0.12) 50%,
                        rgba(165, 148, 255, 0.08) 100%);
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(165, 148, 255, 0.25);
        }

        .insights-btn:active {
            transform: translateY(0px);
            box-shadow: 0 4px 15px rgba(165, 148, 255, 0.2);
        }

        .insights-btn svg {
            filter: drop-shadow(0 0 8px rgba(165, 148, 255, 0.6));
            animation: pulseGlow 2s ease-in-out infinite;
        }

        .grazi-avatar-btn {
            height: 100%;
            width: 52px;
            object-fit: cover;
            object-position: center 20%;
            border: none;
            box-shadow: -3px 0 12px rgba(165, 148, 255, 0.25);
            border-radius: 0 calc(1rem - 1px) calc(1rem - 1px) 0;
            position: absolute;
            right: 0;
            top: 0;
        }

        .insights-notification-badge {
            position: absolute;
            bottom: -8px;
            left: -8px;
            background: #ff3b30;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            box-shadow: 0 3px 10px rgba(255, 59, 48, 0.7);
            z-index: 1001;
        }

        .insights-notification-badge.hidden {
            display: none;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .minutes-usage {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem 1.25rem;
            background: rgba(165, 148, 255, 0.06);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 1rem;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.05rem;
            transition: all 0.3s ease;
            height: 100%;
            width: auto;
            position: relative;
            cursor: help;
            z-index: 100;
        }

        .minutes-usage:hover {
            background: rgba(165, 148, 255, 0.1);
            border-color: rgba(165, 148, 255, 0.3);
        }

        .minutes-value {
            font-weight: 700;
            font-size: 1.05rem;
            color: #A594FF;
            white-space: nowrap;
        }

        .minutes-tooltip {
            position: absolute;
            top: calc(100% + 12px);
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg,
                        rgba(20, 20, 35, 0.98) 0%,
                        rgba(15, 15, 28, 0.98) 100%);
            backdrop-filter: blur(16px);
            color: rgba(255, 255, 255, 0.9);
            padding: 0.65rem 1.1rem;
            border-radius: 0.875rem;
            font-size: 0.875rem;
            font-weight: 600;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5),
                        0 0 0 1px rgba(165, 148, 255, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1.5px solid rgba(165, 148, 255, 0.3);
            z-index: 10000;
            letter-spacing: 0.3px;
        }

        .minutes-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-bottom-color: rgba(165, 148, 255, 0.3);
            z-index: -1;
        }

        .minutes-tooltip::after {
            content: '';
            position: absolute;
            bottom: calc(100% + 1px);
            left: 50%;
            transform: translateX(-50%);
            border: 7px solid transparent;
            border-bottom-color: rgba(20, 20, 35, 0.98);
        }

        .minutes-usage:hover .minutes-tooltip {
            opacity: 1;
            transform: translateX(-50%) translateY(3px);
        }

        @media (max-width: 768px) {
            .header-right {
                flex-direction: column;
                gap: 0.75rem;
            }

            .minutes-usage {
                width: 100%;
                justify-content: center;
            }
        }

        @keyframes pulseGlow {
            0%, 100% {
                filter: drop-shadow(0 0 6px rgba(165, 148, 255, 0.4));
            }
            50% {
                filter: drop-shadow(0 0 12px rgba(165, 148, 255, 0.8));
            }
        }

        .insights-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
            overflow: hidden;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .insights-popup.active {
            display: block;
        }

        /* Bloquear scroll quando popup estiver aberto */
        body.popup-open {
            overflow: hidden !important;
            position: fixed;
            width: 100%;
        }

        .insights-popup-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        .insights-popup-content {
            position: absolute;
            top: 2%;
            left: 2%;
            width: 96%;
            height: 96%;
            background: linear-gradient(135deg, rgba(15, 10, 35, 0.98), rgba(10, 4, 32, 0.98));
            border: 2px solid rgba(165, 148, 255, 0.4);
            border-radius: 2rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* SCROLLBAR DO POPUP - Removido pois agora é chat fullscreen */

        .insights-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 2rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.2);
            background: rgba(255, 255, 255, 0.02);
            flex-shrink: 0;
        }

        .insights-header-title {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .insights-popup-header h2 {
            font-size: 1.6rem;
            font-weight: 800;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .insights-popup-header h2 .grazi-name {
            background: linear-gradient(135deg, #ffffff, #A594FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .insights-header-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .insights-new-chat-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border: 2px solid rgba(165, 148, 255, 0.3);
            background: rgba(165, 148, 255, 0.1);
            border-radius: 0.75rem;
            color: #A594FF;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .insights-new-chat-btn:hover {
            background: rgba(165, 148, 255, 0.2);
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-1px);
        }

        .insights-close-btn {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(165, 148, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .insights-close-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.6);
            transform: rotate(90deg);
        }

        /* CONTAINER PRINCIPAL - CHAT ESTILO ChatGPT/Claude */
        .insights-main-container-chat {
            display: flex;
            flex-direction: row;
            height: calc(100% - 80px);
            padding: 0;
            width: 100%;
            overflow: hidden;
            gap: 0;
        }

        /* SIDEBAR PERGUNTAS RÁPIDAS (DIREITA) */
        .insights-quick-questions-sidebar {
            width: 280px;
            min-width: 280px;
            background: rgba(10, 6, 32, 0.8);
            border-left: 1px solid rgba(165, 148, 255, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .quick-questions-sidebar-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.2);
            background: rgba(255, 255, 255, 0.02);
            font-size: 0.875rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .quick-questions-sidebar-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .quick-questions-sidebar-list::-webkit-scrollbar {
            width: 6px;
        }

        .quick-questions-sidebar-list::-webkit-scrollbar-track {
            background: rgba(165, 148, 255, 0.05);
        }

        .quick-questions-sidebar-list::-webkit-scrollbar-thumb {
            background: rgba(165, 148, 255, 0.3);
            border-radius: 3px;
        }

        .quick-question-sidebar-btn {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.875rem 1rem;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.875rem;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .quick-question-sidebar-btn:hover {
            background: rgba(165, 148, 255, 0.15);
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateX(3px);
        }

        .quick-question-sidebar-btn svg {
            flex-shrink: 0;
            color: #A594FF;
        }

        /* SIDEBAR COM CONVERSAS (ESQUERDA) */
        .insights-chat-sidebar {
            width: 280px;
            min-width: 280px;
            background: rgba(10, 6, 32, 0.8);
            border-right: 1px solid rgba(165, 148, 255, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            flex-shrink: 0;
        }
        
        .sidebar-header svg {
            width: 20px;
            height: 20px;
            color: #A594FF;
        }
        
        .sidebar-conversations-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .sidebar-conversations-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar-conversations-list::-webkit-scrollbar-track {
            background: rgba(165, 148, 255, 0.05);
            border-radius: 10px;
        }
        
        .sidebar-conversations-list::-webkit-scrollbar-thumb {
            background: rgba(165, 148, 255, 0.3);
            border-radius: 10px;
        }
        
        .sidebar-conversations-list::-webkit-scrollbar-thumb:hover {
            background: rgba(165, 148, 255, 0.5);
        }
        
        .sidebar-conversation-item {
            padding: 0.9rem 1rem;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(165, 148, 255, 0.15);
            border-radius: 0.7rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .sidebar-conversation-item:hover {
            background: rgba(165, 148, 255, 0.12);
            border-color: rgba(165, 148, 255, 0.35);
        }
        
        .sidebar-conversation-item.active {
            background: rgba(165, 148, 255, 0.15);
            border-color: rgba(165, 148, 255, 0.5);
        }
        
        .sidebar-conversation-preview {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            line-height: 1.4;
        }
        
        .sidebar-conversation-time {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .sidebar-empty-state {
            padding: 2rem 1rem;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.85rem;
        }

        /* SECAO CHAT FULL SCREEN (DIREITA) */
        .insights-chat-section-full {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            padding: 1.5rem 2rem;
        }
        
        .insights-chat-container-full {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .insights-chat-container-full {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(165deg,
                #0e0828 0%,
                #120b35 25%,
                #0f0a2e 50%,
                #0a0620 75%,
                #0e0828 100%);
            border: 1px solid rgba(165, 148, 255, 0.25);
            border-radius: 1.2rem;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }
        
        .insights-chat-container-full::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 30%, rgba(165, 148, 255, 0.08) 0%, transparent 50%),
                        radial-gradient(circle at 80% 70%, rgba(102, 126, 234, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        /* SECAO CHAT (ESQUERDA) */
        .insights-chat-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-height: 0;
            overflow: hidden;
        }

        .insights-section-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .grazi-avatar-header {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(165, 148, 255, 0.6);
            box-shadow: 0 0 8px rgba(165, 148, 255, 0.3);
        }

        .insights-section-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #A594FF;
            margin: 0;
        }

        /* Container principal do chat */
        .insights-chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(165deg,
                #0e0828 0%,
                #120b35 25%,
                #0f0a2e 50%,
                #0a0620 75%,
                #0e0828 100%);
            border: 1px solid rgba(165, 148, 255, 0.25);
            border-radius: 1.2rem;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }
        
        .insights-chat-container-full {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(165deg,
                #0e0828 0%,
                #120b35 25%,
                #0f0a2e 50%,
                #0a0620 75%,
                #0e0828 100%);
            border: 1px solid rgba(165, 148, 255, 0.25);
            border-radius: 1.2rem;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }
        
        .insights-chat-container-full::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 30%, rgba(165, 148, 255, 0.08) 0%, transparent 50%),
                        radial-gradient(circle at 80% 70%, rgba(102, 126, 234, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .insights-chat-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 30%, rgba(165, 148, 255, 0.08) 0%, transparent 50%),
                        radial-gradient(circle at 80% 70%, rgba(102, 126, 234, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .insights-chat-messages {
            flex: 1;
            padding: 2rem;
            padding-bottom: 1rem;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 1;
            min-height: 0;
        }
        
        .insights-chat-container-full .insights-chat-messages {
            padding: 2rem;
            padding-bottom: 1rem;
        }

        .insights-chat-messages::before {
            display: none;
        }

        .insights-chat-messages::-webkit-scrollbar {
            width: 10px;
        }

        .insights-chat-messages::-webkit-scrollbar-track {
            background: rgba(165, 148, 255, 0.05);
            border-radius: 10px;
        }

        .insights-chat-messages::-webkit-scrollbar-thumb {
            background: rgba(165, 148, 255, 0.3);
            border-radius: 10px;
        }

        .insights-chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(165, 148, 255, 0.5);
        }
        
        .insights-chat-container-full .insights-chat-messages::-webkit-scrollbar {
            width: 10px;
        }

        .insights-welcome-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            padding: 3rem 2rem;
            font-size: 1.1rem;
        }

        .insights-welcome-message p {
            margin: 0;
        }

        /* Mensagens do chat - Estilo ChatGPT/Claude */
        .chat-message {
            margin-bottom: 1.5rem;
            animation: slideInUp 0.4s ease;
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.ai {
            align-items: flex-start;
        }
        
        .chat-message-ai-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .chat-avatar-ai {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(165, 148, 255, 0.4);
            object-fit: cover;
        }

        .chat-sender-name {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .chat-message.user .chat-sender-name {
            color: #A594FF;
            margin-bottom: 0.5rem;
        }

        .chat-message.ai .chat-sender-name {
            color: #A594FF;
        }

        .chat-bubble {
            display: inline-block;
            padding: 1rem 1.25rem;
            border-radius: 1rem;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.6;
        }

        .chat-bubble.user {
            background: linear-gradient(135deg, #A594FF, #667eea);
            color: white;
            border-bottom-right-radius: 0.25rem;
        }

        .chat-bubble.ai {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(165, 148, 255, 0.2);
            color: rgba(255, 255, 255, 0.9);
            border-bottom-left-radius: 0.25rem;
        }
        
        .highlight-purple {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.6), rgba(118, 75, 162, 0.6));
            padding: 2px 6px;
            border-radius: 4px;
            color: #ffffff;
            font-weight: 700;
        }
        
        .chat-bubble.ai strong {
            color: #A594FF;
            font-weight: 600;
        }

        .chat-bubble.loading {
            padding: 1rem 2rem;
        }

        .loading-dots {
            display: inline-flex;
            gap: 0.4rem;
        }

        .loading-dots span {
            width: 8px;
            height: 8px;
            background: #A594FF;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* INPUT DE CHAT - Estilo integrado e moderno */
        .insights-chat-input-container {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            padding: 1.25rem 1.5rem;
            background: rgba(10, 6, 32, 0.8);
            border-top: 1px solid rgba(165, 148, 255, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 2;
            margin: 0;
            flex-shrink: 0;
        }
        
        .insights-chat-container-full .insights-chat-input-container {
            border-top: 1px solid rgba(165, 148, 255, 0.2);
        }
        
        /* PERGUNTAS RÁPIDAS ABAIXO DO INPUT */
        .insights-quick-questions-below {
            padding: 1rem 1.5rem;
            background: rgba(10, 6, 32, 0.6);
            border-top: 1px solid rgba(165, 148, 255, 0.15);
            border-bottom: 1px solid rgba(165, 148, 255, 0.15);
            flex-shrink: 0;
        }
        
        .quick-questions-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(165, 148, 255, 0.8);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .quick-questions-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .quick-question-btn-below {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 0.9rem;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 0.6rem;
            color: rgba(255, 255, 255, 0.85);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Raleway', sans-serif;
            white-space: nowrap;
        }
        
        .quick-question-btn-below:hover {
            background: rgba(165, 148, 255, 0.15);
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-1px);
        }
        
        .quick-question-btn-below svg {
            flex-shrink: 0;
            width: 14px;
            height: 14px;
        }
        

        .insights-chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(165, 148, 255, 0.25);
            border-radius: 0.85rem;
            outline: none;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.88rem;
            padding: 0.85rem 1.15rem;
            font-family: 'Raleway', sans-serif;
            transition: all 0.3s ease;
        }

        .insights-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }

        .insights-chat-input:focus {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(165, 148, 255, 0.5);
            box-shadow: 0 0 0 3px rgba(165, 148, 255, 0.1);
        }

        .insights-chat-send-btn {
            background: linear-gradient(135deg, #A594FF 0%, #8B7EE8 100%);
            border: none;
            border-radius: 0.75rem;
            padding: 0.85rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(165, 148, 255, 0.25);
        }

        .insights-chat-send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(165, 148, 255, 0.4);
            background: linear-gradient(135deg, #B5A4FF 0%, #9B8FF8 100%);
        }

        .insights-chat-send-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(165, 148, 255, 0.3);
        }

        .insights-chat-send-btn svg {
            color: white;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }

        /* PERGUNTAS RAPIDAS (DIREITA SUPERIOR) */
        .insights-quick-questions-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-height: 0;
            overflow: hidden;
        }

        .insights-quick-questions {
            flex: 1;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 1.2rem;
            padding: 1.3rem;
            display: flex;
            flex-direction: column;
            gap: 0.95rem;
            overflow: visible;
            justify-content: flex-start;
        }

        .insights-quick-questions h4 {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .quick-question-btn {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            text-align: left;
            padding: 0.9rem 1.1rem;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 0.8rem;
            color: rgba(255, 255, 255, 0.85);
            font-size: 0.88rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Raleway', sans-serif;
        }

        .quick-question-btn:hover {
            background: rgba(165, 148, 255, 0.15);
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateX(5px);
        }

        .quick-question-btn svg {
            flex-shrink: 0;
        }

        /* BOTAO TOGGLE INSIGHTS */
        .insights-toggle-btn {
            width: 100%;
            padding: 0.9rem 1.5rem;
            margin-top: 0.5rem;
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.12), rgba(102, 126, 234, 0.08));
            border: 1px solid rgba(165, 148, 255, 0.35);
            border-radius: 1rem;
            color: white;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.7rem;
            transition: all 0.3s ease;
            font-family: 'Raleway', sans-serif;
            box-shadow: 0 4px 15px rgba(165, 148, 255, 0.1);
        }

        .insights-toggle-btn:hover {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.18), rgba(102, 126, 234, 0.12));
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(165, 148, 255, 0.2);
        }

        .insights-toggle-btn svg {
            transition: transform 0.3s ease;
        }

        /* CONTAINER COMPLETO DE INSIGHTS (SEM ACORDEAO) */
        .insights-full-container {
            margin-top: 0.5rem;
        }


        /* DISPLAY DA DATA ATUAL */
        .current-date-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.8rem;
            padding: 0.75rem 1rem;
            background: rgba(165, 148, 255, 0.08);
            border: 1px solid rgba(165, 148, 255, 0.2);
            border-radius: 0.5rem;
        }

        .current-date-info {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .current-date-info svg {
            flex-shrink: 0;
        }

        .current-date-label {
            font-size: 0.95rem;
            font-weight: 700;
            color: #A594FF;
            letter-spacing: 0.3px;
        }

        .choose-date-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 1rem;
            background: rgba(165, 148, 255, 0.15);
            border: 1px solid rgba(165, 148, 255, 0.4);
            border-radius: 0.4rem;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .choose-date-btn:hover {
            background: rgba(165, 148, 255, 0.25);
            border-color: rgba(165, 148, 255, 0.6);
            transform: translateY(-1px);
        }

        .choose-date-btn svg {
            flex-shrink: 0;
        }

        /* WRAPPER DO CALENDÁRIO - FLUTUANTE/DROPDOWN COMPACTO */
        #calendarWrapper {
            position: absolute;
            top: 100%;
            right: 0;
            transform: translateY(-10px);
            margin-top: 0.5rem;
            padding: 1rem;
            background: linear-gradient(135deg,
                rgba(30, 25, 50, 0.98),
                rgba(25, 20, 45, 0.98));
            border: 2px solid rgba(165, 148, 255, 0.5);
            border-radius: 0.8rem;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.7),
                        0 0 40px rgba(165, 148, 255, 0.25),
                        inset 0 1px 0 rgba(165, 148, 255, 0.15);
            z-index: 1000;
            backdrop-filter: blur(20px);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            width: max-content;
            max-width: 320px;
        }

        #calendarWrapper.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        /* Seta do dropdown apontando para o botão */
        #calendarWrapper::before {
            content: '';
            position: absolute;
            top: -8px;
            right: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(165, 148, 255, 0.5);
        }

        #calendarWrapper::after {
            content: '';
            position: absolute;
            top: -6px;
            right: 21px;
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-bottom: 7px solid rgba(30, 25, 50, 0.98);
        }

        /* Container pai precisa ser relative para o absolute funcionar */
        .insights-date-selector {
            position: relative;
            margin-bottom: 1rem;
            padding-bottom: 0.9rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.2);
        }

        .date-selector-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.7rem;
            padding-bottom: 0.6rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.15);
        }

        .date-selector-title-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .date-selector-title-group svg {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
        }

        .date-selector-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .calendar-month-nav {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .calendar-month-label {
            font-size: 0.9rem;
            font-weight: 700;
            color: #ffffff;
            min-width: 130px;
            text-align: center;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 8px rgba(165, 148, 255, 0.4);
        }

        .calendar-nav-btn {
            background: rgba(165, 148, 255, 0.12);
            border: 1px solid rgba(165, 148, 255, 0.35);
            border-radius: 0.35rem;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.25s ease;
            color: #A594FF;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .calendar-nav-btn:hover {
            background: rgba(165, 148, 255, 0.25);
            border-color: rgba(165, 148, 255, 0.6);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(165, 148, 255, 0.3);
        }

        .calendar-nav-btn:active {
            transform: scale(0.95);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.35rem;
            max-width: 280px;
            margin: 0 auto;
        }

        .calendar-weekday {
            text-align: center;
            font-size: 0.68rem;
            font-weight: 700;
            color: rgba(165, 148, 255, 0.85);
            padding: 0.35rem 0;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.4rem;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.03);
            border: 1.5px solid rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.25);
            cursor: not-allowed;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 34px;
        }

        .calendar-day.empty {
            opacity: 0;
            pointer-events: none;
        }

        .calendar-day.available {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.15), rgba(102, 126, 234, 0.1));
            border-color: rgba(165, 148, 255, 0.4);
            color: rgba(255, 255, 255, 0.95);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(165, 148, 255, 0.15);
        }

        .calendar-day.available:hover {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.3), rgba(102, 126, 234, 0.2));
            border-color: rgba(165, 148, 255, 0.7);
            transform: scale(1.12);
            box-shadow: 0 4px 20px rgba(165, 148, 255, 0.4);
            color: #ffffff;
        }

        .calendar-day.active {
            background: linear-gradient(135deg, #A594FF, #667EEA);
            border-color: #A594FF;
            color: #ffffff;
            font-weight: 800;
            box-shadow: 0 4px 20px rgba(165, 148, 255, 0.6),
                        0 0 30px rgba(165, 148, 255, 0.3);
            transform: scale(1.05);
        }

        .calendar-day.active:hover {
            transform: scale(1.15);
        }

        .calendar-day.today {
            border-color: #667EEA;
            box-shadow: 0 0 12px rgba(102, 126, 234, 0.4);
        }

        .date-loading {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            font-style: italic;
            text-align: center;
            padding: 0.5rem;
        }

        /* CAIXA PRINCIPAL DE INSIGHTS */
        .insights-single-box {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.01));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(165, 148, 255, 0.25);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 1rem;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
        }

        /* LINHA DA GRADE 2x2 */
        .insights-grid-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.2rem;
            margin-bottom: 1.2rem;
        }

        /* MINI CARDS (2x2) */
        .insight-mini-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 1px solid rgba(165, 148, 255, 0.3);
            border-radius: 0.9rem;
            padding: 1rem;
            transition: all 0.3s ease;
            height: 160px;
            display: flex;
            flex-direction: column;
        }

        .insight-mini-card:hover {
            border-color: rgba(165, 148, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(165, 148, 255, 0.15);
        }

        .insight-mini-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.7rem;
            padding-bottom: 0.6rem;
            border-bottom: 1px solid rgba(165, 148, 255, 0.2);
            flex-shrink: 0;
        }

        .insight-mini-header svg {
            flex-shrink: 0;
        }

        .insight-mini-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: #A594FF;
        }

        .insight-mini-content {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.82rem;
            line-height: 1.55;
            white-space: pre-wrap;
            flex: 1;
            overflow-y: auto;
            max-height: 95px;
            padding-right: 0.3rem;
        }

        .insight-mini-content::-webkit-scrollbar {
            width: 5px;
        }

        .insight-mini-content::-webkit-scrollbar-track {
            background: rgba(165, 148, 255, 0.05);
            border-radius: 10px;
        }

        .insight-mini-content::-webkit-scrollbar-thumb {
            background: rgba(165, 148, 255, 0.3);
            border-radius: 10px;
        }

        .insight-mini-content::-webkit-scrollbar-thumb:hover {
            background: rgba(165, 148, 255, 0.5);
        }

        /* CARD ESPECIAL - CONSIDERAÇÕES FINAIS */
        .insight-final-card {
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.15), rgba(102, 126, 234, 0.1));
            border: 2px solid rgba(165, 148, 255, 0.5);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 10px 30px rgba(165, 148, 255, 0.2);
            transition: all 0.3s ease;
        }

        .insight-final-card:hover {
            border-color: rgba(165, 148, 255, 0.7);
            box-shadow: 0 12px 35px rgba(165, 148, 255, 0.3);
            transform: translateY(-2px);
        }

        .insight-final-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid rgba(165, 148, 255, 0.3);
        }

        .insight-final-header svg {
            flex-shrink: 0;
        }

        .insight-final-title {
            font-size: 1.15rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ffffff, #A594FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .insight-final-content {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
            line-height: 1.7;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .insight-final-content::-webkit-scrollbar {
            width: 6px;
        }

        .insight-final-content::-webkit-scrollbar-track {
            background: rgba(165, 148, 255, 0.1);
            border-radius: 10px;
        }

        .insight-final-content::-webkit-scrollbar-thumb {
            background: rgba(165, 148, 255, 0.4);
            border-radius: 10px;
        }

        .insight-final-content::-webkit-scrollbar-thumb:hover {
            background: rgba(165, 148, 255, 0.6);
        }

        /* DATA NO RODAPE */
        .insight-date-footer {
            text-align: right;
            font-size: 0.78rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 0.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(165, 148, 255, 0.15);
        }

        /* POPUP CUSTOMIZADO */
        .custom-alert-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 99999;
            animation: fadeIn 0.2s ease;
        }

        .custom-alert-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .custom-alert-box {
            background: linear-gradient(135deg, rgba(15, 10, 35, 0.98), rgba(10, 4, 32, 0.98));
            border: 2px solid rgba(165, 148, 255, 0.4);
            border-radius: 1.5rem;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            animation: slideInUp 0.3s ease;
        }

        .custom-alert-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #A594FF;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .custom-alert-message {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .custom-alert-btn {
            width: 100%;
            padding: 0.875rem;
            background: linear-gradient(135deg, #A594FF, #667eea);
            border: none;
            border-radius: 0.75rem;
            color: white;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Raleway', sans-serif;
        }

        .custom-alert-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(165, 148, 255, 0.5);
        }

        /* ANIMACOES */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* RESPONSIVO */
        @media (max-width: 1024px) {
            .dashboard-header {
                flex-direction: column;
                align-items: stretch;
            }

            .insights-btn {
                width: 100%;
                justify-content: center;
            }

            .insights-top-section {
                grid-template-columns: 1fr;
            }

            .insights-popup-content {
                top: 2%;
                left: 2%;
                width: 96%;
                height: 96%;
            }
        }

        @media (max-width: 768px) {
            .insights-popup-header {
                padding: 1.5rem;
            }

            .insights-main-container {
                padding: 1.5rem;
            }

            .insights-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .insight-card {
                min-height: 200px;
                max-height: 300px;
            }

            /* Esconder sidebars em mobile */
            .insights-chat-sidebar,
            .insights-quick-questions-sidebar {
                display: none;
            }

            .insights-chat-section-full {
                width: 100%;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .insights-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Scripts de Tutorial (SEM onboarding - tooltips só aparecem em páginas de demo) -->
    <link rel="stylesheet" href="../css/tutorial-button.css">
    <script src="../js/tutorial-button.js"></script>
    
    <div class="dashboard-container">
        <div class="dashboard-header">
            <div>
                <h1 class="dashboard-title">Dashboard de Métricas</h1>
                <p class="dashboard-subtitle">Acompanhe o desempenho das suas chamadas em tempo real</p>
            </div>
            <div class="header-right">
                <div class="minutes-usage">
                    <span class="minutes-value" id="minutesUsed">0 / 500</span>
                    <span class="minutes-tooltip">Minutos usados até o momento</span>
                </div>
            </div>
        </div>

        <div class="error-message" id="errorMessage">
            <strong>Erro:</strong> <span id="errorText"></span>
        </div>

        <div class="filters-section">
            <div class="filter-group">
                <label class="filter-label">Período</label>
                <select class="filter-select" id="periodFilter">
                    <option value="today">Hoje</option>
                    <option value="yesterday">Ontem</option>
                    <option value="7days" selected>Últimos 7 dias</option>
                    <option value="30days">Últimos 30 dias</option>
                </select>
            </div>

            <div class="filter-group">
                <label class="filter-label">Assistente</label>
                <select class="filter-select" id="assistantFilter">
                    <option value="all">Todos os Assistentes</option>
                </select>
            </div>

            <button class="apply-filters-btn" id="updateBtn" onclick="loadDashboard(); loadAgendamentos(); loadGraziWidgetSummary();">
                <span id="btnText">Atualizar Dados</span>
            </button>
        </div>

        <div class="kpis-grid" id="kpisGrid">
            <!-- CARD GRANDE COM GRÁFICO - OCUPA 2 COLUNAS -->
            <div class="kpi-card with-chart">
                <div class="kpi-header">
                    <div class="kpi-icon purple">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                        </svg>
                    </div>
                    <span class="kpi-label" id="callsLabel">Total de Chamadas</span>
                </div>
                <div class="kpi-content">
                    <div class="kpi-stats">
                        <div class="kpi-value" id="kpiTotalCalls">
                            <div class="skeleton skeleton-number"></div>
                        </div>
                        <div class="kpi-change neutral" id="kpiTotalCallsChange">
                            <div class="skeleton skeleton-small"></div>
                        </div>
                    </div>
                    <div class="kpi-chart-container">
                        <div class="chart-wrapper" id="chartTotalCalls">
                            <div class="skeleton skeleton-chart"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CARDS PEQUENOS VERTICAIS -->
            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon green">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#22C55E" stroke-width="2">
                            <line x1="12" y1="1" x2="12" y2="23"/>
                            <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
                        </svg>
                    </div>
                    <span class="kpi-label">Custo Total</span>
                </div>
                <div class="kpi-value" id="kpiTotalCost">
                    <div class="skeleton skeleton-number"></div>
                </div>
                <div class="kpi-change neutral" id="kpiTotalCostChange">
                    <div class="skeleton skeleton-small"></div>
                </div>
            </div>

            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon blue">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3B82F6" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 6v6l4 2"/>
                        </svg>
                    </div>
                    <span class="kpi-label">Total de Minutos</span>
                </div>
                <div class="kpi-value" id="kpiTotalMinutes">
                    <div class="skeleton skeleton-number"></div>
                </div>
                <div class="kpi-change neutral" id="kpiTotalMinutesChange">
                    <div class="skeleton skeleton-small"></div>
                </div>
            </div>

            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon orange">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#FB923C" stroke-width="2">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                            <line x1="16" y1="2" x2="16" y2="6"/>
                            <line x1="8" y1="2" x2="8" y2="6"/>
                            <line x1="3" y1="10" x2="21" y2="10"/>
                        </svg>
                    </div>
                    <span class="kpi-label">Total de Agendamentos</span>
                </div>
                <div class="kpi-value" id="kpiSuccessRate">
                    <div class="skeleton skeleton-number"></div>
                </div>
                <div class="kpi-change neutral" id="kpiSuccessRateChange">
                    <div class="skeleton skeleton-small"></div>
                </div>
            </div>

            <div class="kpi-card">
                <div class="kpi-header">
                    <div class="kpi-icon purple">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12 6 12 12 16 14"/>
                        </svg>
                    </div>
                    <span class="kpi-label">Duração Média</span>
                </div>
                <div class="kpi-value" id="kpiAvgDuration">
                    <div class="skeleton skeleton-number"></div>
                </div>
                <div class="kpi-change neutral" id="kpiAvgDurationChange">
                    <div class="skeleton skeleton-small"></div>
                </div>
            </div>
            <!-- WIDGET GRAZI - FORMATO ESTICADO COM LAYOUT EM SEÇÕES -->
            <div class="kpi-card grazi-widget-stretched" id="graziWidget">
                <div class="kpi-header grazi-widget-header-custom">
                    <div class="grazi-header-with-avatar">
                        <img src="https://gwjcgzeybqiyqezuswpt.supabase.co/storage/v1/object/public/profile-pictures/GRAZI.png" alt="Grazi" class="grazi-widget-avatar-small">
                        <span class="kpi-label">
                            <span class="grazi-name-mini">Grazi</span> <span class="grazi-ai-badge-mini">A.I</span>
                        </span>
                    </div>
                    <button class="grazi-widget-more-btn-top" onclick="openInsightsPopup()">
                        Falar com a Grazi
                    </button>
                </div>
                <div class="grazi-widget-sections" id="graziWidgetContent">
                    <div class="grazi-widget-loading">
                        <div class="skeleton" style="height: 14px; margin-bottom: 6px;"></div>
                        <div class="skeleton" style="height: 14px; margin-bottom: 6px;"></div>
                        <div class="skeleton" style="height: 14px; margin-bottom: 6px;"></div>
                        <div class="skeleton" style="height: 14px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- WIDGET GRAZI - ANTES DE "CHAMADAS POR TIPO" (REMOVIDO - AGORA ESTÁ NO GRID ACIMA) -->

        <div class="metrics-section" id="metricsSection">
            <div class="metric-card">
                <div class="metric-header">
                    <h3 class="metric-title">Chamadas por Tipo</h3>
                </div>
                <div class="metrics-list" id="callsByType">
                    <div class="skeleton" style="height: 60px;"></div>
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <h3 class="metric-title">Performance por Assistente</h3>
                </div>
                <div class="metrics-list" id="assistantPerformance">
                    <div class="skeleton" style="height: 60px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Boas-vindas (Tooltip) - SÓ aparece em páginas de demo -->
    <!-- No sistema principal, este modal está sempre oculto -->
    <div class="welcome-tooltip-overlay" id="welcomeTooltipOverlay" style="display: none !important; visibility: hidden !important;">
        <div class="welcome-tooltip-modal">
            <div class="welcome-tooltip-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                </svg>
            </div>
            <h1 class="welcome-tooltip-title">Bem-vindo ao Salesdever!</h1>
            <p class="welcome-tooltip-subtitle">Sua plataforma completa de automação de vendas</p>
            <p class="welcome-tooltip-description">
                O Salesdever é uma plataforma poderosa que ajuda você a automatizar suas vendas, gerenciar campanhas e acompanhar resultados em tempo real. Com inteligência artificial integrada, você pode aumentar sua produtividade e fechar mais negócios.
            </p>
            <div class="welcome-tooltip-features">
                <h3>O que você vai aprender no tour:</h3>
                <div class="welcome-tooltip-feature-item">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="9" y1="9" x2="15" y2="9"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    <span>Dashboard com métricas em tempo real</span>
                </div>
                <div class="welcome-tooltip-feature-item">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <span>Criação e gerenciamento de campanhas</span>
                </div>
                <div class="welcome-tooltip-feature-item">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                        <path d="M2 17l10 5 10-5"/>
                        <path d="M2 12l10 5 10-5"/>
                    </svg>
                    <span>Assistentes de IA personalizados</span>
                </div>
                <div class="welcome-tooltip-feature-item">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                    <span>Grazi A.I - Sua assistente virtual inteligente</span>
                </div>
                <div class="welcome-tooltip-feature-item">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>Gerenciamento de contatos e conversas</span>
                </div>
            </div>
            <div class="welcome-tooltip-buttons">
                <button class="welcome-tooltip-btn-primary" onclick="startTour()">
                    Sim, quero fazer o tour!
                </button>
                <button class="welcome-tooltip-btn-secondary" onclick="skipTour()">
                    Pular por enquanto
                </button>
            </div>
        </div>
    </div>

    <style>
        .welcome-tooltip-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .welcome-tooltip-modal {
            background: rgba(13, 11, 26, 0.98);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(165, 148, 255, 0.3);
            border-radius: 20px;
            padding: 2.5rem;
            max-width: 550px;
            width: 100%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(165, 148, 255, 0.2),
                        0 0 0 1px rgba(165, 148, 255, 0.1) inset;
            animation: slideUp 0.4s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-tooltip-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 1.5rem;
            background: linear-gradient(135deg, rgba(165, 148, 255, 0.2), rgba(102, 126, 234, 0.2));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(165, 148, 255, 0.3);
        }

        .welcome-tooltip-title {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, #ffffff, #A594FF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
        }

        .welcome-tooltip-subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 1.25rem;
            font-weight: 400;
        }

        .welcome-tooltip-description {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.5;
            margin-bottom: 2rem;
        }

        .welcome-tooltip-features {
            text-align: left;
            margin-bottom: 2rem;
            padding: 1.25rem;
            background: rgba(165, 148, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(165, 148, 255, 0.1);
        }

        .welcome-tooltip-features h3 {
            font-size: 1rem;
            color: #A594FF;
            margin-bottom: 0.875rem;
            text-align: center;
        }

        .welcome-tooltip-feature-item {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            margin-bottom: 0.625rem;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.875rem;
        }

        .welcome-tooltip-feature-item:last-child {
            margin-bottom: 0;
        }

        .welcome-tooltip-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .welcome-tooltip-btn-primary,
        .welcome-tooltip-btn-secondary {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-family: 'Raleway', sans-serif;
        }

        .welcome-tooltip-btn-primary {
            background: linear-gradient(135deg, #A594FF, #667EEA);
            color: white;
            box-shadow: 0 4px 16px rgba(165, 148, 255, 0.3);
        }

        .welcome-tooltip-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(165, 148, 255, 0.4);
        }

        .welcome-tooltip-btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .welcome-tooltip-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 768px) {
            .welcome-tooltip-overlay {
                padding: 1rem;
            }

            .welcome-tooltip-modal {
                padding: 1.5rem;
                border-radius: 16px;
            }

            .welcome-tooltip-title {
                font-size: 1.5rem;
            }

            .welcome-tooltip-buttons {
                flex-direction: column;
            }
        }
    </style>

    <script>
        let userData = null;
        let assistantsCache = {};

        // Verificar primeiro login e mostrar tooltip de boas-vindas
        // IMPORTANTE: Tooltip de boas-vindas NÃO deve aparecer no sistema principal
        // Só deve aparecer em páginas de demo
        function checkFirstLoginAndShowWelcome() {
            // Verificar se é página de demo
            const path = window.location.pathname;
            const href = window.location.href;
            const isDemo = path.includes('onboarding-tutorial-demo') || 
                          href.includes('onboarding-tutorial-demo') ||
                          (window.parent && window.parent !== window && 
                           (window.parent.location.pathname.includes('onboarding-tutorial-demo-menu') ||
                            window.parent.location.href.includes('onboarding-tutorial-demo-menu')));
            
            // Se NÃO for página de demo, NÃO mostrar tooltip de boas-vindas
            if (!isDemo) {
                console.log('[Dashboard] ⚠️ Sistema principal detectado - tooltip de boas-vindas NÃO será exibido');
                console.log('[Dashboard] Tooltips só aparecem em páginas de demo');
                return; // NÃO mostrar no sistema principal
            }
            
            console.log('[Dashboard] ✅ Página de demo confirmada - verificando primeiro login...');
            
            let tenantId = localStorage.getItem('tenant_id');
            if (!tenantId) {
                try {
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    tenantId = userData.user?.tenant_id || userData.tenant_id || 'default';
                } catch (e) {
                    tenantId = 'default';
                }
            }
            
            if (!tenantId) {
                tenantId = 'default';
            }
            
            const userKey = `onboarding_first_login_${tenantId}`;
            const firstLogin = localStorage.getItem(userKey);
            
            console.log('[Dashboard] Tenant ID:', tenantId);
            console.log('[Dashboard] Chave:', userKey);
            console.log('[Dashboard] First Login:', firstLogin);
            
            // Se é o primeiro login (não tem firstLogin marcado), mostrar tooltip (apenas em demo)
            if (!firstLogin && isDemo) {
                console.log('[Dashboard] ✅ Primeiro login detectado em página de demo! Mostrando tooltip de boas-vindas...');
                const overlay = document.getElementById('welcomeTooltipOverlay');
                if (overlay) {
                    overlay.style.display = 'flex';
                }
            } else if (!firstLogin && !isDemo) {
                console.log('[Dashboard] ⚠️ Primeiro login detectado, mas é sistema principal - tooltip NÃO será exibido');
                // Garantir que overlay está oculto
                const overlay = document.getElementById('welcomeTooltipOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }
        }

        function startTour() {
            // Marcar primeiro login
            let tenantId = localStorage.getItem('tenant_id');
            if (!tenantId) {
                try {
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    tenantId = userData.user?.tenant_id || userData.tenant_id || 'default';
                } catch (e) {
                    tenantId = 'default';
                }
            }
            
            if (!tenantId) {
                tenantId = 'default';
            }
            
            const userKey = `onboarding_first_login_${tenantId}`;
            localStorage.setItem(userKey, 'true');
            localStorage.setItem(`onboarding_first_login_date_${tenantId}`, new Date().toISOString());
            localStorage.setItem('onboarding_wants_tour', 'true');
            
            // Fechar tooltip
            const overlay = document.getElementById('welcomeTooltipOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            
            // Redirecionar para o menu de tutorial (que carrega o dashboard de teste)
            console.log('[Dashboard] Redirecionando para menu de tutorial...');
            console.log('[Dashboard] window.parent !== window?', window.parent !== window);
            console.log('[Dashboard] window.location.href atual:', window.location.href);
            console.log('[Dashboard] window.location.pathname:', window.location.pathname);
            
            if (window.parent && window.parent !== window) {
                // Se está em iframe, redirecionar o parent para o menu de tutorial
                console.log('[Dashboard] Está em iframe, redirecionando parent...');
                console.log('[Dashboard] Parent location:', window.parent.location.href);
                console.log('[Dashboard] Parent pathname:', window.parent.location.pathname);
                
                // O parent (menu.html) está no mesmo diretório que onboarding-tutorial-demo-menu.html
                // Usar caminho relativo simples - o parent está em menu_principal/
                const parentPath = window.parent.location.pathname;
                const parentDir = parentPath.substring(0, parentPath.lastIndexOf('/'));
                const newPath = parentDir + '/onboarding-tutorial-demo-menu.html';
                console.log('[Dashboard] Redirecionando parent para:', newPath);
                console.log('[Dashboard] URL completa será:', window.parent.location.origin + newPath);
                window.parent.location.href = window.parent.location.origin + newPath;
            } else {
                // Se está direto, redirecionar para o menu de tutorial
                console.log('[Dashboard] Redirecionando diretamente...');
                // Dashboard está em dashboard/, precisa subir um nível
                const currentPath = window.location.pathname;
                const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/'));
                const parentDir = currentDir.substring(0, currentDir.lastIndexOf('/'));
                const newPath = parentDir + '/onboarding-tutorial-demo-menu.html';
                console.log('[Dashboard] Redirecionando para:', newPath);
                console.log('[Dashboard] URL completa será:', window.location.origin + newPath);
                window.location.href = window.location.origin + newPath;
            }
        }

        function skipTour() {
            // Marcar primeiro login
            let tenantId = localStorage.getItem('tenant_id');
            if (!tenantId) {
                try {
                    const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                    tenantId = userData.user?.tenant_id || userData.tenant_id || 'default';
                } catch (e) {
                    tenantId = 'default';
                }
            }
            
            if (!tenantId) {
                tenantId = 'default';
            }
            
            const userKey = `onboarding_first_login_${tenantId}`;
            localStorage.setItem(userKey, 'true');
            localStorage.setItem(`onboarding_first_login_date_${tenantId}`, new Date().toISOString());
            
            // Fechar tooltip
            const overlay = document.getElementById('welcomeTooltipOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        window.addEventListener('load', async () => {
            console.log('🚀 Dashboard iniciado');
            
            if (!loadUserData()) {
                alert('Dados de login não encontrados. Faça login novamente.');
                window.location.href = 'login.html';
                return;
            }

            console.log('✅ userData carregado:', userData);
            
            // Verificar se é sistema principal e garantir que tooltip não apareça
            const path = window.location.pathname;
            const href = window.location.href;
            const isDemo = path.includes('onboarding-tutorial-demo') || 
                          href.includes('onboarding-tutorial-demo') ||
                          (window.parent && window.parent !== window && 
                           (window.parent.location.pathname.includes('onboarding-tutorial-demo-menu') ||
                            window.parent.location.href.includes('onboarding-tutorial-demo-menu')));
            
            if (!isDemo) {
                // Sistema principal - garantir que tooltip está oculto
                const overlay = document.getElementById('welcomeTooltipOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.visibility = 'hidden';
                    console.log('[Dashboard] ✅ Tooltip de boas-vindas oculto no sistema principal');
                }
            } else {
                // Página de demo - verificar primeiro login e mostrar tooltip se necessário
                checkFirstLoginAndShowWelcome();
            }
            
            // Carregar assistentes primeiro, depois dashboard e agendamentos em paralelo
            await loadAssistants();
            await Promise.all([
                loadDashboard(),
                loadAgendamentos()
            ]);
            // Recarregar widget da Grazi após carregar dashboard
            loadGraziWidgetSummary();
            
            // Verificar se deve abrir Grazi Insights automaticamente (vindo da página de ajuda)
            const shouldOpenInsights = sessionStorage.getItem('open_grazi_insights_on_load') === 'true';
            if (shouldOpenInsights) {
                console.log('[Dashboard] 🎯 Abrindo Grazi Insights automaticamente (solicitado da página de ajuda)...');
                sessionStorage.removeItem('open_grazi_insights_on_load');
                
                // Aguardar um pouco para garantir que tudo carregou
                setTimeout(() => {
                    if (typeof openInsightsPopup === 'function') {
                        openInsightsPopup();
                        console.log('[Dashboard] ✅ Grazi Insights aberta com memória preservada');
                    } else {
                        console.warn('[Dashboard] ⚠️ openInsightsPopup não disponível ainda, tentando novamente...');
                        setTimeout(() => {
                            if (typeof openInsightsPopup === 'function') {
                                openInsightsPopup();
                            }
                        }, 500);
                    }
                }, 500);
            }
        });

        function loadUserData() {
            try {
                const stored = localStorage.getItem('userData');
                if (!stored) return false;

                userData = JSON.parse(stored);
                return true;
            } catch (error) {
                console.error('❌ Erro ao carregar dados:', error);
                return false;
            }
        }

        async function loadAssistants() {
            try {
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                
                console.log('🔍 Buscando assistentes para tenant:', tenantId);
                
                const response = await fetch('https://sdr.salesdever.io/webhook/dashboard-metricas', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        period: '7days',
                        assistant_id: 'all'
                    })
                });

                if (response.ok) {
                    const rawData = await response.json();
                    console.log('📥 Resposta RAW para assistentes:', rawData);
                    
                    if (Array.isArray(rawData) && rawData.length > 0) {
                        assistantsCache = {};
                        
                        rawData.forEach((item, index) => {
                            const id = item.assistente_id || item.assistant_id;
                            const name = item.name || item.assistant_name || item.assistente_name;
                            
                            if (id && name && !assistantsCache[id]) {
                                assistantsCache[id] = name;
                                console.log(`✅ Assistente encontrado: ${name} (${id})`);
                            }
                        });
                        
                        console.log('✅ Cache de assistentes:', assistantsCache);
                        
                        if (Object.keys(assistantsCache).length > 0) {
                            populateAssistantFilter();
                        } else {
                            console.warn('⚠️ Nenhum assistente encontrado no cache');
                        }
                    }
                }
            } catch (error) {
                console.error('❌ Erro ao carregar assistentes:', error);
            }
        }

        function populateAssistantFilter() {
            const select = document.getElementById('assistantFilter');
            select.innerHTML = '<option value="all">Todos os Assistentes</option>';
            
            Object.entries(assistantsCache).forEach(([id, name]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = name;
                select.appendChild(option);
            });
            
            console.log('✅ Select populado com', select.options.length - 1, 'assistentes');
        }

        async function loadDashboard() {
            const btn = document.getElementById('updateBtn');
            const btnText = document.getElementById('btnText');
            
            btn.classList.add('loading');
            btnText.textContent = 'Carregando...';
            hideError();

            try {
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const period = document.getElementById('periodFilter').value;
                const assistantId = document.getElementById('assistantFilter').value;

                console.log('📤 Buscando dados dashboard:', { tenant_id: tenantId, period, assistant_id: assistantId });

                const response = await fetch('https://sdr.salesdever.io/webhook/dashboard-metricas', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        period: period,
                        assistant_id: assistantId
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erro HTTP ${response.status}`);
                }

                // Tentar ler o texto da resposta primeiro
                const responseText = await response.text();
                console.log('📥 Resposta recebida (texto):', responseText.substring(0, 200));

                let rawData = [];
                let callsData = [];

                // Se a resposta estiver vazia, não é um erro - apenas não há dados ainda
                if (!responseText || responseText.trim() === '') {
                    console.log('📭 Resposta vazia - conta nova sem dados');
                    const metrics = calculateMetrics([], assistantId, period);
                    updateDashboard(metrics);
                    return;
                }

                // Tentar parsear JSON
                try {
                    rawData = JSON.parse(responseText);
                    console.log('📥 Dados recebidos (RAW):', rawData);
                } catch (jsonError) {
                    console.warn('⚠️ Resposta não é JSON válido, tratando como sem dados');
                    const metrics = calculateMetrics([], assistantId, period);
                    updateDashboard(metrics);
                    return;
                }

                if (Array.isArray(rawData)) {
                    callsData = rawData.filter(item => {
                        return item.vapi_call_id || item.duration_seconds !== undefined || item.cost !== undefined;
                    });

                    console.log('📊 Total de itens no array:', rawData.length);
                    console.log('📊 Calls filtradas:', callsData.length);
                }

                if (!callsData || callsData.length === 0) {
                    console.log('📭 Nenhuma call encontrada - conta ainda sem dados');
                    // Mesmo sem dados, calcular métricas vazias para o período
                    const metrics = calculateMetrics([], assistantId, period);
                    updateDashboard(metrics);
                    return;
                }

                const metrics = calculateMetrics(callsData, assistantId, period);
                console.log('📊 Métricas calculadas:', metrics);

                updateDashboard(metrics);

            } catch (error) {
                console.error('❌ Erro:', error);
                // Só mostrar erro se for realmente um erro de rede ou servidor, não dados vazios
                if (error.message.includes('HTTP') || error.message.includes('fetch') || error.message.includes('network')) {
                    showError(`Falha ao carregar dados: ${error.message}`);
                } else {
                    console.log('📭 Tratando como conta sem dados');
                    const assistantId = document.getElementById('assistantFilter').value;
                    const period = document.getElementById('periodFilter').value;
                    const metrics = calculateMetrics([], assistantId, period);
                    updateDashboard(metrics);
                }
            } finally {
                btn.classList.remove('loading');
                btnText.textContent = 'Atualizar Dados';
            }
        }

        async function loadAgendamentos() {
            try {
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const period = document.getElementById('periodFilter').value;

                console.log('📅 Buscando agendamentos para tenant:', tenantId, 'período:', period);

                const response = await fetch('https://sdr.salesdever.io/webhook/agendamentos-eventos-listar', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tenant_id: tenantId
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erro HTTP ${response.status}`);
                }

                const responseText = await response.text();
                console.log('📥 Resposta agendamentos:', responseText.substring(0, 200));

                let agendamentos = [];

                if (responseText && responseText.trim() !== '') {
                    try {
                        const data = JSON.parse(responseText);
                        if (Array.isArray(data)) {
                            agendamentos = data;
                        }
                    } catch (jsonError) {
                        console.warn('⚠️ Resposta não é JSON válido');
                    }
                }

                console.log('📅 Total de agendamentos antes do filtro:', agendamentos.length);

                // FILTRAR AGENDAMENTOS POR PERÍODO
                let filteredAgendamentos = agendamentos;
                let previousPeriodAgendamentos = agendamentos;
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                if (period === 'today') {
                    // Apenas agendamentos de HOJE
                    filteredAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate.getTime() === today.getTime();
                    });
                    console.log('📅 HOJE: Filtrando', agendamentos.length, '→', filteredAgendamentos.length, 'agendamentos');

                    // Período anterior: ONTEM
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    previousPeriodAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate.getTime() === yesterday.getTime();
                    });
                    console.log('📅 ONTEM (comparação): Filtrando', agendamentos.length, '→', previousPeriodAgendamentos.length, 'agendamentos');
                } else if (period === 'yesterday') {
                    // Apenas agendamentos de ONTEM
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    filteredAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate.getTime() === yesterday.getTime();
                    });
                    console.log('📅 ONTEM: Filtrando', agendamentos.length, '→', filteredAgendamentos.length, 'agendamentos');

                    // Período anterior: ANTEONTEM
                    const dayBeforeYesterday = new Date(today);
                    dayBeforeYesterday.setDate(dayBeforeYesterday.getDate() - 2);
                    previousPeriodAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate.getTime() === dayBeforeYesterday.getTime();
                    });
                    console.log('📅 ANTEONTEM (comparação): Filtrando', agendamentos.length, '→', previousPeriodAgendamentos.length, 'agendamentos');
                } else if (period === '7days') {
                    // Últimos 7 dias
                    const sevenDaysAgo = new Date(today);
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 6);
                    filteredAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate >= sevenDaysAgo && agendamentoDate <= today;
                    });
                    console.log('📅 7 DIAS: Filtrando', agendamentos.length, '→', filteredAgendamentos.length, 'agendamentos');

                    // Período anterior: 7 dias anteriores (dias 8-14 atrás)
                    const fourteenDaysAgo = new Date(today);
                    fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 13);
                    const eightDaysAgo = new Date(today);
                    eightDaysAgo.setDate(eightDaysAgo.getDate() - 7);
                    previousPeriodAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate >= fourteenDaysAgo && agendamentoDate < eightDaysAgo;
                    });
                    console.log('📅 7 DIAS ANTERIORES (comparação): Filtrando', agendamentos.length, '→', previousPeriodAgendamentos.length, 'agendamentos');
                } else if (period === '30days') {
                    // Últimos 30 dias
                    const thirtyDaysAgo = new Date(today);
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);
                    filteredAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate >= thirtyDaysAgo && agendamentoDate <= today;
                    });
                    console.log('📅 30 DIAS: Filtrando', agendamentos.length, '→', filteredAgendamentos.length, 'agendamentos');

                    // Período anterior: 30 dias anteriores (dias 31-60 atrás)
                    const sixtyDaysAgo = new Date(today);
                    sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 59);
                    const thirtyOneDaysAgo = new Date(today);
                    thirtyOneDaysAgo.setDate(thirtyOneDaysAgo.getDate() - 30);
                    previousPeriodAgendamentos = agendamentos.filter(agendamento => {
                        const dataField = agendamento.created_at || agendamento.data_agendamento || agendamento.data;
                        if (!dataField) return false;
                        const agendamentoDate = new Date(dataField);
                        agendamentoDate.setHours(0, 0, 0, 0);
                        return agendamentoDate >= sixtyDaysAgo && agendamentoDate < thirtyOneDaysAgo;
                    });
                    console.log('📅 30 DIAS ANTERIORES (comparação): Filtrando', agendamentos.length, '→', previousPeriodAgendamentos.length, 'agendamentos');
                }

                const totalAgendamentos = filteredAgendamentos.length;
                const prevTotalAgendamentos = previousPeriodAgendamentos.length;
                console.log('📅 Total de agendamentos após filtro:', totalAgendamentos);
                console.log('📅 Total de agendamentos período anterior:', prevTotalAgendamentos);

                // Calcular mudança percentual
                const agendamentosChange = prevTotalAgendamentos > 0
                    ? ((totalAgendamentos - prevTotalAgendamentos) / prevTotalAgendamentos) * 100
                    : 0;

                console.log('📊 Mudança em agendamentos:', agendamentosChange > 0 ? '+' : '', agendamentosChange.toFixed(1), '%');

                // Cache para o widget Grazi (bloco Agendamentos usa o mesmo lugar que o KPI)
                const periodLabel = document.getElementById('periodFilter') ? document.getElementById('periodFilter').options[document.getElementById('periodFilter').selectedIndex].text : 'período';
                window.__lastAgendamentos = {
                    total: totalAgendamentos,
                    change: agendamentosChange,
                    period: period,
                    periodLabel: periodLabel,
                    list: filteredAgendamentos
                };

                // Atualizar o KPI com a mudança percentual
                updateKPI('kpiSuccessRate', totalAgendamentos, agendamentosChange);

            } catch (error) {
                console.error('❌ Erro ao buscar agendamentos:', error);
                updateKPI('kpiSuccessRate', 0, 0);
                window.__lastAgendamentos = { total: 0, change: 0, period: 'today', periodLabel: 'Hoje', list: [] };
            }
        }

        function calculateMetrics(calls, assistantFilter, period) {
            console.log('🧮 Calculando métricas de', calls.length, 'calls para período:', period);

            // FILTRAR CALLS POR PERÍODO ANTES DE TUDO
            let filteredByPeriod = calls;
            let filteredByPreviousPeriod = calls;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (period === 'today') {
                // Apenas chamadas de HOJE
                filteredByPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate.getTime() === today.getTime();
                });
                console.log('📅 HOJE: Filtrando', calls.length, '→', filteredByPeriod.length, 'calls');

                // Período anterior: ONTEM
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                filteredByPreviousPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate.getTime() === yesterday.getTime();
                });
                console.log('📅 ONTEM (comparação): Filtrando', calls.length, '→', filteredByPreviousPeriod.length, 'calls');
            } else if (period === 'yesterday') {
                // Apenas chamadas de ONTEM
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                filteredByPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate.getTime() === yesterday.getTime();
                });
                console.log('📅 ONTEM: Filtrando', calls.length, '→', filteredByPeriod.length, 'calls');

                // Período anterior: ANTEONTEM
                const dayBeforeYesterday = new Date(today);
                dayBeforeYesterday.setDate(dayBeforeYesterday.getDate() - 2);
                filteredByPreviousPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate.getTime() === dayBeforeYesterday.getTime();
                });
                console.log('📅 ANTEONTEM (comparação): Filtrando', calls.length, '→', filteredByPreviousPeriod.length, 'calls');
            } else if (period === '7days') {
                // Últimos 7 dias
                const sevenDaysAgo = new Date(today);
                sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 6);
                filteredByPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate >= sevenDaysAgo && callDate <= today;
                });
                console.log('📅 7 DIAS: Filtrando', calls.length, '→', filteredByPeriod.length, 'calls');

                // Período anterior: 7 dias anteriores (dias 8-14 atrás)
                const fourteenDaysAgo = new Date(today);
                fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 13);
                const eightDaysAgo = new Date(today);
                eightDaysAgo.setDate(eightDaysAgo.getDate() - 7);
                filteredByPreviousPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate >= fourteenDaysAgo && callDate < eightDaysAgo;
                });
                console.log('📅 7 DIAS ANTERIORES (comparação): Filtrando', calls.length, '→', filteredByPreviousPeriod.length, 'calls');
            } else if (period === '30days') {
                // Últimos 30 dias
                const thirtyDaysAgo = new Date(today);
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);
                filteredByPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate >= thirtyDaysAgo && callDate <= today;
                });
                console.log('📅 30 DIAS: Filtrando', calls.length, '→', filteredByPeriod.length, 'calls');

                // Período anterior: 30 dias anteriores (dias 31-60 atrás)
                const sixtyDaysAgo = new Date(today);
                sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 59);
                const thirtyOneDaysAgo = new Date(today);
                thirtyOneDaysAgo.setDate(thirtyOneDaysAgo.getDate() - 30);
                filteredByPreviousPeriod = calls.filter(call => {
                    if (!call.started_at) return false;
                    const callDate = new Date(call.started_at);
                    callDate.setHours(0, 0, 0, 0);
                    return callDate >= sixtyDaysAgo && callDate < thirtyOneDaysAgo;
                });
                console.log('📅 30 DIAS ANTERIORES (comparação): Filtrando', calls.length, '→', filteredByPreviousPeriod.length, 'calls');
            }

            // Aplicar filtro de assistente em ambos os períodos
            let filteredCalls = filteredByPeriod;
            let previousPeriodCalls = filteredByPreviousPeriod;
            if (assistantFilter && assistantFilter !== 'all') {
                filteredCalls = filteredByPeriod.filter(c => c.assistente_id === assistantFilter || c.assistant_id === assistantFilter);
                previousPeriodCalls = filteredByPreviousPeriod.filter(c => c.assistente_id === assistantFilter || c.assistant_id === assistantFilter);
            }

            // CALCULAR MÉTRICAS DO PERÍODO ATUAL
            const totalCalls = filteredCalls.length;
            const totalCost = filteredCalls.reduce((sum, call) => sum + parseFloat(call.cost || 0), 0);

            // CALCULAR TOTAL DE SEGUNDOS
            const totalSeconds = filteredCalls.reduce((sum, call) => {
                return sum + parseFloat(call.duration_seconds || 0);
            }, 0);

            console.log('═══════════════════════════════════════');
            console.log(`📊 RESUMO DE DURAÇÃO (${filteredCalls.length} calls):`);
            console.log(`- Total segundos: ${totalSeconds}s`);
            console.log(`- Total minutos: ${(totalSeconds / 60).toFixed(2)} min`);
            console.log('═══════════════════════════════════════');

            const avgDuration = totalCalls > 0 ? totalSeconds / totalCalls : 0;
            console.log(`- Duração média: ${avgDuration.toFixed(2)}s (${(avgDuration / 60).toFixed(2)} min)`);

            // CALCULAR MÉTRICAS DO PERÍODO ANTERIOR
            const prevTotalCalls = previousPeriodCalls.length;
            const prevTotalCost = previousPeriodCalls.reduce((sum, call) => sum + parseFloat(call.cost || 0), 0);
            const prevTotalSeconds = previousPeriodCalls.reduce((sum, call) => {
                return sum + parseFloat(call.duration_seconds || 0);
            }, 0);
            const prevAvgDuration = prevTotalCalls > 0 ? prevTotalSeconds / prevTotalCalls : 0;

            console.log('═══════════════════════════════════════');
            console.log('📊 PERÍODO ANTERIOR:');
            console.log(`- Calls: ${prevTotalCalls}`);
            console.log(`- Custo: ${prevTotalCost}`);
            console.log(`- Total segundos: ${prevTotalSeconds}s`);
            console.log(`- Duração média: ${prevAvgDuration.toFixed(2)}s`);
            console.log('═══════════════════════════════════════');

            // CALCULAR MUDANÇAS PERCENTUAIS
            const callsChange = prevTotalCalls > 0 ? ((totalCalls - prevTotalCalls) / prevTotalCalls) * 100 : 0;
            const costChange = prevTotalCost > 0 ? ((totalCost - prevTotalCost) / prevTotalCost) * 100 : 0;
            const minutesChange = prevTotalSeconds > 0 ? ((totalSeconds - prevTotalSeconds) / prevTotalSeconds) * 100 : 0;
            const avgDurationChange = prevAvgDuration > 0 ? ((avgDuration - prevAvgDuration) / prevAvgDuration) * 100 : 0;

            console.log('═══════════════════════════════════════');
            console.log('📊 MUDANÇAS PERCENTUAIS:');
            console.log(`- Calls: ${callsChange > 0 ? '+' : ''}${callsChange.toFixed(1)}%`);
            console.log(`- Custo: ${costChange > 0 ? '+' : ''}${costChange.toFixed(1)}%`);
            console.log(`- Minutos: ${minutesChange > 0 ? '+' : ''}${minutesChange.toFixed(1)}%`);
            console.log(`- Duração Média: ${avgDurationChange > 0 ? '+' : ''}${avgDurationChange.toFixed(1)}%`);
            console.log('═══════════════════════════════════════');

            // CALCULAR TAXA DE SUCESSO (usando success_evaluation)
            const successfulCalls = filteredCalls.filter(c => {
                return c.success_evaluation === true || c.success_evaluation === 'true';
            }).length;
            const successRate = totalCalls > 0 ? (successfulCalls / totalCalls) * 100 : 0;
            console.log(`✅ Taxa de sucesso: ${successfulCalls}/${totalCalls} (${successRate.toFixed(1)}%)`);

            const callsByStatus = {};
            filteredCalls.forEach(call => {
                const status = call.status || 'unknown';
                callsByStatus[status] = (callsByStatus[status] || 0) + 1;
            });

            const endedCalls = filteredCalls.filter(c => c.status === 'ended').length;
            const noAnswerCalls = filteredCalls.filter(c => c.ended_reason === 'no-answer' || c.status === 'no-answer').length;
            const responseRate = {
                answered: endedCalls,
                not_answered: noAnswerCalls
            };

            const callsByType = {};
            filteredCalls.forEach(call => {
                const type = call.call_type || call.call_direction || 'unknown';
                callsByType[type] = (callsByType[type] || 0) + 1;
            });

            // CALCULAR PERFORMANCE POR ASSISTENTE (usando success_evaluation)
            console.log('═══════════════════════════════════════');
            console.log('📊 CALCULANDO PERFORMANCE POR ASSISTENTE:');
            const assistantPerformance = {};
            filteredCalls.forEach(call => {
                const assistentId = call.assistente_id || call.assistant_id || 'unknown';
                if (!assistantPerformance[assistentId]) {
                    assistantPerformance[assistentId] = { total: 0, successful: 0 };
                }
                assistantPerformance[assistentId].total++;

                const isSuccess = call.success_evaluation === true || call.success_evaluation === 'true';
                if (isSuccess) {
                    assistantPerformance[assistentId].successful++;
                }
            });

            console.log('📊 Performance calculada para', Object.keys(assistantPerformance).length, 'assistentes');

            const dailyData = createDailyData(filteredCalls, period);

            return {
                total_calls: totalCalls,
                total_cost: totalCost,
                total_duration_seconds: totalSeconds,
                avg_duration: avgDuration,
                calls_by_status: callsByStatus,
                response_rate: responseRate,
                calls_by_type: callsByType,
                assistant_performance: assistantPerformance,
                daily_calls: dailyData.calls,
                period: period,
                // Mudanças percentuais
                calls_change: callsChange,
                cost_change: costChange,
                minutes_change: minutesChange,
                avg_duration_change: avgDurationChange
            };
        }

        function createDailyData(calls, period) {
            // Determinar número de dias baseado no período
            let days = 7;
            switch(period) {
                case 'today': days = 1; break;
                case 'yesterday': days = 1; break;
                case '7days': days = 7; break;
                case '30days': days = 30; break;
            }
            
            const dailyCalls = new Array(days).fill(0);
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Para "ontem", ajustar a data base
            let baseDate = new Date(today);
            if (period === 'yesterday') {
                baseDate.setDate(baseDate.getDate() - 1);
            }
            
            calls.forEach(call => {
                if (!call.started_at) return;
                
                const callDate = new Date(call.started_at);
                callDate.setHours(0, 0, 0, 0);
                
                let diffTime;
                if (period === 'yesterday') {
                    diffTime = baseDate - callDate;
                } else {
                    diffTime = today - callDate;
                }
                
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays >= 0 && diffDays < days) {
                    const index = days - 1 - diffDays;
                    dailyCalls[index]++;
                }
            });
            
            return { calls: dailyCalls };
        }

        function showEmptyState() {
            document.getElementById('kpiTotalCalls').textContent = '0';
            document.getElementById('kpiTotalCallsChange').innerHTML = '<span>→</span><span>0.0% vs período anterior</span>';

            document.getElementById('kpiTotalCost').textContent = 'R$ 0.00';
            document.getElementById('kpiTotalCostChange').innerHTML = '<span>→</span><span>0.0% vs período anterior</span>';

            document.getElementById('kpiTotalMinutes').textContent = '0.00 min';
            document.getElementById('kpiTotalMinutesChange').innerHTML = '<span>→</span><span>0.0% vs período anterior</span>';

            document.getElementById('kpiSuccessRate').textContent = '0';
            document.getElementById('kpiSuccessRateChange').innerHTML = '<span>→</span><span>0 vs período anterior</span>';

            document.getElementById('kpiAvgDuration').textContent = '0 seg';
            document.getElementById('kpiAvgDurationChange').innerHTML = '<span>→</span><span>0.0% vs período anterior</span>';

            // Mostrar gráfico vazio
            const period = document.getElementById('periodFilter').value;
            createMiniChart('chartTotalCalls', [], period);

            const metricsSection = document.getElementById('metricsSection');
            metricsSection.innerHTML = `
                <div class="empty-state">
                    <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                    </svg>
                    <h3>Nenhuma chamada encontrada</h3>
                    <p>Não há dados de chamadas para o período e assistente selecionados.</p>
                </div>
            `;
        }

        function updateDashboard(data) {
            console.log('═══════════════════════════════════════');
            console.log('🎨 ATUALIZANDO DASHBOARD');
            console.log('📥 Dados recebidos:', data);
            console.log('═══════════════════════════════════════');
            
            const totalCalls = data.total_calls || 0;
            const totalCost = data.total_cost || 0;
            const avgDuration = data.avg_duration || 0;
            const period = data.period || '7days';
            
            // Atualizar label do card de chamadas conforme o período
            const periodLabels = {
                'today': 'Chamadas Hoje',
                'yesterday': 'Chamadas Ontem',
                '7days': 'Chamadas Últimos 7 dias',
                '30days': 'Chamadas Últimos 30 dias'
            };
            document.getElementById('callsLabel').textContent = periodLabels[period] || 'Total de Chamadas';
            
            // ═══ CÁLCULO DE DURAÇÃO ═══
            let totalSeconds = 0;
            if (data.total_duration_seconds !== undefined) {
                totalSeconds = data.total_duration_seconds;
                console.log('✅ Usando total_duration_seconds:', totalSeconds);
            } else if (data.total_minutes !== undefined) {
                totalSeconds = data.total_minutes * 60;
                console.log('⚠️ Convertendo total_minutes para segundos:', totalSeconds);
            } else {
                totalSeconds = avgDuration * totalCalls;
                console.log('⚠️ FALLBACK: calculando de avg_duration * total_calls:', totalSeconds);
            }
            
            const totalMinutes = totalSeconds / 60;
            
            console.log('═══════════════════════════════════════');
            console.log('📊 VALORES FINAIS:');
            console.log(`- Total segundos: ${totalSeconds}s`);
            console.log(`- Total minutos: ${totalMinutes.toFixed(2)} min`);
            console.log(`- Duração média: ${avgDuration.toFixed(2)}s`);
            console.log('═══════════════════════════════════════');
            
            // ═══ CÁLCULO DE CUSTO ═══
            const multiplier = userData.multiplo_plano || parseFloat(localStorage.getItem('multiplo_plano')) || 1.0;
            const adjustedCost = totalMinutes * multiplier;
            
            console.log('💰 CÁLCULO DE CUSTO:');
            console.log(`- Multiplicador: ${multiplier}`);
            console.log(`- Custo ajustado: R$ ${adjustedCost.toFixed(2)}`);
            console.log('═══════════════════════════════════════');
            
            updateKPI('kpiTotalCalls', totalCalls, data.calls_change || 0);
            updateKPI('kpiTotalCost', `R$ ${adjustedCost.toFixed(2)}`, data.cost_change || 0);
            updateKPI('kpiTotalMinutes', `${totalMinutes.toFixed(2)} min`, data.minutes_change || 0);
            updateKPI('kpiAvgDuration', formatDuration(avgDuration), data.avg_duration_change || 0);

            createMiniChart('chartTotalCalls', data.daily_calls || [], period);

            updateCallsByType(data.calls_by_type || {});
            updateAssistantPerformance(data.assistant_performance || {});
        }

        function createMiniChart(elementId, dataPoints, period) {
            const container = document.getElementById(elementId);
            if (!container) return;
            
            container.innerHTML = '';
            
            // Se não há dados reais, mostrar gráfico vazio (todos zeros)
            if (!dataPoints || dataPoints.length === 0 || dataPoints.every(v => v === 0)) {
                const days = period === 'today' || period === 'yesterday' ? 1 : 
                             period === '30days' ? 30 : 7;
                dataPoints = new Array(days).fill(0);
            }
            
            const canvas = document.createElement('canvas');
            container.appendChild(canvas);
            
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.innerHTML = '<div class="tooltip-value">0</div><div class="tooltip-date">-</div>';
            document.body.appendChild(tooltip);
            
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            function resizeCanvas() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                ctx.scale(dpr, dpr);
                drawChart();
            }
            
            function drawChart() {
                const rect = container.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                const padding = { left: 15, right: 15, top: 15, bottom: 35 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                ctx.clearRect(0, 0, width, height);
                
                const max = Math.max(...dataPoints, 1);
                const min = 0;
                const range = max > 0 ? max : 1;
                
                // Para um único ponto, centralizar
                const step = dataPoints.length > 1 ? chartWidth / (dataPoints.length - 1) : 0;
                const points = dataPoints.map((value, index) => {
                    const x = dataPoints.length === 1 ? 
                              padding.left + chartWidth / 2 : 
                              padding.left + index * step;
                    // Se max é 0, colocar no meio do gráfico
                    const y = max > 0 ? 
                              padding.top + chartHeight - ((value - min) / range) * chartHeight :
                              padding.top + chartHeight / 2;
                    return { x, y, value };
                });
                
                // Linhas de grid horizontais
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 3; i++) {
                    const y = padding.top + (chartHeight / 3) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                }
                
                // Área preenchida apenas se houver mais de 1 ponto
                if (points.length > 1) {
                    const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
                    gradient.addColorStop(0, 'rgba(165, 148, 255, 0.25)');
                    gradient.addColorStop(1, 'rgba(165, 148, 255, 0.0)');
                    
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.lineTo(width - padding.right, height - padding.bottom);
                    ctx.lineTo(padding.left, height - padding.bottom);
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Linha principal
                    const lineGradient = ctx.createLinearGradient(0, 0, width, 0);
                    lineGradient.addColorStop(0, '#667eea');
                    lineGradient.addColorStop(1, '#A594FF');
                    
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.strokeStyle = lineGradient;
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }
                
                // Pontos
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = '#A594FF';
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();
                });
                
                // Labels dos dias
                ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
                ctx.font = '11px Raleway';
                ctx.textAlign = 'center';
                
                const days = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
                const today = new Date();
                
                // Ajustar exibição de labels baseado no período
                let showEvery = 1;
                if (dataPoints.length > 15) showEvery = Math.floor(dataPoints.length / 10);
                
                points.forEach((point, index) => {
                    if (dataPoints.length === 1 || index % showEvery === 0 || index === points.length - 1) {
                        const dayOffset = dataPoints.length - 1 - index;
                        const date = new Date(today);
                        
                        if (period === 'yesterday') {
                            date.setDate(date.getDate() - 1);
                        } else {
                            date.setDate(date.getDate() - dayOffset);
                        }
                        
                        let label;
                        if (period === 'today') {
                            label = 'Hoje';
                        } else if (period === 'yesterday') {
                            label = 'Ontem';
                        } else if (dataPoints.length <= 7) {
                            label = days[date.getDay()];
                        } else {
                            label = date.getDate() + '/' + (date.getMonth() + 1);
                        }
                        
                        ctx.fillText(label, point.x, height - 12);
                    }
                });
                
                return points;
            }
            
            resizeCanvas();
            const points = drawChart();
            
            // Interação com mouse
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                let closestPoint = null;
                let closestDistance = Infinity;
                
                points.forEach((point, index) => {
                    const distance = Math.abs(mouseX - point.x);
                    
                    if (distance < closestDistance && distance < 40) {
                        closestDistance = distance;
                        closestPoint = { ...point, index };
                    }
                });
                
                if (closestPoint) {
                    const today = new Date();
                    const dayOffset = dataPoints.length - 1 - closestPoint.index;
                    const date = new Date(today);
                    
                    if (period === 'yesterday') {
                        date.setDate(date.getDate() - 1);
                    } else {
                        date.setDate(date.getDate() - dayOffset);
                    }
                    
                    const days = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
                    const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                    
                    tooltip.querySelector('.tooltip-value').textContent = Math.round(closestPoint.value);
                    tooltip.querySelector('.tooltip-date').textContent = days[date.getDay()] + ', ' + date.getDate() + ' ' + months[date.getMonth()];
                    
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY - 60) + 'px';
                    tooltip.classList.add('visible');
                } else {
                    tooltip.classList.remove('visible');
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
            });
            
            window.addEventListener('resize', resizeCanvas);
        }

        function updateKPI(elementId, value, change) {
            const element = document.getElementById(elementId);

            // Verificar se o valor é numérico ou string com formato de moeda/unidade
            const isNumeric = typeof value === 'number';
            const isMoneyString = typeof value === 'string' && value.includes('R$');
            const isMinutesString = typeof value === 'string' && value.includes('min');
            const isDurationString = typeof value === 'string' && (value.includes('seg') || value.includes('m '));

            if (isNumeric) {
                // Animar número puro
                animateValue(element, 0, value, 600);
            } else if (isMoneyString) {
                // Extrair valor numérico e animar
                const numValue = parseFloat(value.replace('R$', '').replace(/\s/g, '').replace(',', '.'));
                if (!isNaN(numValue)) {
                    animateValue(element, 0, numValue, 600, (val) => `R$ ${val.toFixed(2)}`);
                } else {
                    element.textContent = value;
                }
            } else if (isMinutesString && !isDurationString) {
                // Extrair valor numérico e animar
                const numValue = parseFloat(value.replace('min', '').trim());
                if (!isNaN(numValue)) {
                    animateValue(element, 0, numValue, 600, (val) => `${val.toFixed(2)} min`);
                } else {
                    element.textContent = value;
                }
            } else {
                // Para duração complexa (5m 30s) ou outros, apenas mostrar sem animação
                element.textContent = value;
            }

            const changeEl = document.getElementById(elementId + 'Change');
            const arrow = change > 0 ? '↗' : (change < 0 ? '↘' : '→');
            const className = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');

            changeEl.innerHTML = `<span>${arrow}</span><span>${change > 0 ? '+' : ''}${change.toFixed(1)}% vs período anterior</span>`;
            changeEl.className = `kpi-change ${className}`;
        }

        function animateValue(element, start, end, duration, formatter = null) {
            if (!element) return;

            const startTime = performance.now();

            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease out quad para animação mais suave e rápida
                const easeProgress = 1 - Math.pow(1 - progress, 2);
                const currentValue = start + (end - start) * easeProgress;

                if (formatter) {
                    element.textContent = formatter(currentValue);
                } else {
                    element.textContent = Math.round(currentValue);
                }

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }

            requestAnimationFrame(update);
        }

        function updateCallsByType(data) {
            const container = document.getElementById('callsByType');
            container.innerHTML = '';
            
            const labels = { 
                'inbound': 'Entrada', 
                'outbound': 'Saída', 
                'webCall': 'Web',
                'inboundPhoneCall': 'Entrada'
            };
            
            const total = Object.values(data).reduce((sum, val) => sum + val, 0);

            Object.entries(data).forEach(([type, count]) => {
                const percentage = total > 0 ? (count / total) * 100 : 0;
                const label = labels[type] || type;
                
                container.innerHTML += `
                    <div>
                        <div class="metric-item">
                            <span class="metric-item-label">${label}</span>
                            <span class="metric-item-value">${count}</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar">
                                <div class="progress-bar-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }

        function updateAssistantPerformance(data) {
            const container = document.getElementById('assistantPerformance');
            container.innerHTML = '';

            console.log('🎯 Atualizando Performance por Assistente:', data);
            console.log('🎯 Cache de assistentes:', assistantsCache);

            // Verificar se há dados
            if (!data || Object.keys(data).length === 0) {
                container.innerHTML = '<div class="metric-item"><span class="metric-item-label">Nenhum dado disponível</span></div>';
                return;
            }

            Object.entries(data).forEach(([assistantId, stats]) => {
                console.log(`🎯 Processando assistente ${assistantId}:`, stats);

                const name = assistantsCache[assistantId] || assistantId || 'Desconhecido';
                const total = stats.total || 0;
                const successful = stats.successful || 0;
                const successRate = total > 0 ? (successful / total) * 100 : 0;

                console.log(`  Nome: ${name}`);
                console.log(`  Total: ${total}`);
                console.log(`  Sucesso: ${successful}`);
                console.log(`  Taxa: ${successRate.toFixed(1)}%`);

                container.innerHTML += `
                    <div>
                        <div class="metric-item">
                            <span class="metric-item-label">${name}</span>
                            <span class="metric-item-value">${total} chamadas (${successRate.toFixed(1)}% sucesso)</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar">
                                <div class="progress-bar-fill green" style="width: ${successRate}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }

        function formatDuration(seconds) {
            if (!seconds || seconds < 1) return '0 seg';
            if (seconds < 60) return `${Math.floor(seconds)} seg`;
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return secs > 0 ? `${mins}m ${secs}s` : `${mins} min`;
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            errorText.textContent = message;
            errorEl.classList.add('show');
        }

        function hideError() {
            document.getElementById('errorMessage').classList.remove('show');
        }

        // ============================================
        // IA INSIGHTS - FUNCOES
        // ============================================

        // Remove emojis e símbolos decorativos do texto (só texto puro nos cards).
        function stripEmojis(text) {
            if (!text || typeof text !== 'string') return text || '';
            return text.replace(/[\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F600}-\u{1F64F}\u{1F1E0}-\u{1F1FF}\u{FE00}-\u{FE0F}\u{200D}\u{2300}-\u{23FF}\u{2B50}\u{2705}\u{274C}\u{2753}\u{2764}\u{2795}\u{2796}\u{2797}\u{27A1}\u{27B0}\u{27BF}\u{2934}\u{2935}\u{3030}\u{303D}\u{3297}\u{3299}]/gu, '').replace(/\s+/g, ' ').trim();
        }

        // Chamar a Grazi (Edge Function): ela já tem acesso a geral/ligações/conversas no prompt;
        // só passamos o dado de agendamentos do dashboard. Retorna { geral, calls, conversas, agendamentos } ou null.
        async function fetchGraziCardSummaries(tenantId, dataFiltro, agendamentosInfo) {
            const GRAZI_EDGE_CONFIG = window.GRAZI_EDGE_CONFIG || {
                SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3amNnemV5YnFpeXFlenVzd3B0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0NTYwMDgsImV4cCI6MjA3NjAzMjAwOH0.vAXY2hibMpBZofIziY2dKHi1ZICFLaupuD1IhtJU7x4',
                EDGE_FUNCTION_URL: 'https://gwjcgzeybqiyqezuswpt.supabase.co/functions/v1/grazi-chat'
            };
            const n = agendamentosInfo.total != null ? agendamentosInfo.total : 0;
            const label = agendamentosInfo.periodLabel || 'Período';
            const message = `Responda exatamente como você responderia no chat, mas em um único JSON com 4 chaves. Use as métricas que você já tem. Sem emojis. Apenas texto.

- Para "geral": responda como se tivessem perguntado "Qual o resumo de hoje?"
- Para "calls": responda como se tivessem perguntado "Quantas ligações foram feitas hoje?"
- Para "conversas": responda como se tivessem perguntado "Quantas pessoas falamos hoje no WhatsApp?"
- Para "agendamentos": use só este dado do dashboard: ${label}: ${n} agendamento(s).

Responda SOMENTE com um JSON válido, sem markdown, sem emojis: {"geral":"...","calls":"...","conversas":"...","agendamentos":"..."}`;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 25000);
                const response = await fetch(GRAZI_EDGE_CONFIG.EDGE_FUNCTION_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + GRAZI_EDGE_CONFIG.SUPABASE_ANON_KEY },
                    body: JSON.stringify({
                        message: message,
                        tenant_id: tenantId,
                        data_filtro: dataFiltro || new Date().toISOString().split('T')[0],
                        session_id: 'cards_' + Date.now(),
                        history: [],
                        chat_mode: 'insights',
                        frontend_context: { pagina: 'dashboard', modo: 'cards' }
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) return null;
                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let fullText = '';
                let buffer = '';
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    for (const line of lines) {
                        const t = line.trim();
                        if (!t || t.startsWith('event:') || t.startsWith('id:') || t.startsWith('retry:')) continue;
                        let data = t.startsWith('data: ') ? t.slice(6) : (t.startsWith('{') ? t : null);
                        if (!data || data === '[DONE]') continue;
                        try {
                            const parsed = JSON.parse(data);
                            if (parsed.content) fullText += parsed.content;
                            if (parsed.response && !parsed.content) fullText = parsed.response;
                        } catch (_) {}
                    }
                }
                if (buffer) {
                    try {
                        const parsed = JSON.parse(buffer.startsWith('data: ') ? buffer.slice(6) : buffer);
                        if (parsed.content) fullText += parsed.content;
                        if (parsed.response && !parsed.content) fullText = parsed.response;
                    } catch (_) {}
                }
                fullText = fullText.trim();
                if (!fullText) return null;
                let jsonStr = fullText;
                const codeMatch = fullText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeMatch) jsonStr = codeMatch[1].trim();
                else {
                    const first = fullText.indexOf('{');
                    const last = fullText.lastIndexOf('}');
                    if (first !== -1 && last > first) jsonStr = fullText.slice(first, last + 1);
                }
                const out = JSON.parse(jsonStr);
                return {
                    geral: stripEmojis((out.geral || '').trim()) || 'Nenhuma informação disponível.',
                    calls: stripEmojis((out.calls || '').trim()) || 'Nenhuma informação disponível.',
                    conversas: stripEmojis((out.conversas || '').trim()) || 'Nenhuma informação disponível.',
                    agendamentos: stripEmojis((out.agendamentos || '').trim()) || 'Nenhuma informação disponível.'
                };
            } catch (e) {
                console.warn('[Grazi Widget] Grazi cards falhou:', e);
                return null;
            }
        }

        // Carregar dados resumidos da Grazi no widget (resposta da Grazi nos 4 balões)
        async function loadGraziWidgetSummary() {
            console.log('[Grazi Widget] Carregando resumo...');
            
            const widgetContent = document.getElementById('graziWidgetContent');
            if (!widgetContent) return;

            // Loading até a Grazi gerar os textos
            widgetContent.innerHTML = `
                <div class="grazi-widget-loading">
                    <div class="skeleton" style="height: 12px; margin-bottom: 5px;"></div>
                    <div class="skeleton" style="height: 12px; margin-bottom: 5px;"></div>
                    <div class="skeleton" style="height: 12px; margin-bottom: 5px;"></div>
                    <div class="skeleton" style="height: 12px;"></div>
                </div>
            `;

            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    widgetContent.innerHTML = '<p style="color: rgba(255,255,255,0.6);">Erro: Tenant ID não encontrado</p>';
                    return;
                }

                const today = new Date().toISOString().split('T')[0];
                const agInfo = window.__lastAgendamentos ? {
                    total: window.__lastAgendamentos.total,
                    periodLabel: window.__lastAgendamentos.periodLabel || 'Período',
                    change: window.__lastAgendamentos.change,
                    list: window.__lastAgendamentos.list
                } : { total: 0, periodLabel: 'Período' };

                // 1) Chamar a Grazi primeiro; só ela preenche os cards (resposta exata dela, sem dados intermediários)
                let geralText, ligacoesText, conversasText, agendamentosText;
                let geralFullText, ligacoesFullText, conversasFullText, agendamentosFullText;

                const graziCards = await fetchGraziCardSummaries(tenantId, today, agInfo);
                if (graziCards) {
                    geralFullText = graziCards.geral;
                    ligacoesFullText = graziCards.calls;
                    conversasFullText = graziCards.conversas;
                    agendamentosFullText = graziCards.agendamentos;
                    function summarizeText(content, maxLength) {
                        if (!content) return 'Nenhuma informação disponível.';
                        const s = content.split(/[.!?]+/).filter(function (x) { return x.trim().length > 0; });
                        let sum = s.length ? s[0].trim() : content.substring(0, maxLength);
                        if (sum.length > maxLength) sum = sum.substring(0, maxLength) + '...';
                        else if (s.length > 1) sum += '...';
                        return sum;
                    }
                    geralText = summarizeText(geralFullText, 35);
                    ligacoesText = summarizeText(ligacoesFullText, 35);
                    conversasText = summarizeText(conversasFullText, 35);
                    agendamentosText = summarizeText(agendamentosFullText, 35);
                    console.log('[Grazi Widget] Cards preenchidos pela resposta da Grazi');
                } else {
                    // Fallback: só quando a Grazi falhar; buscar ia_insights e webhook
                    let geralData = {}, ligacoesData = {}, conversasData = {}, agendamentosData = {};
                    try {
                        const apiRes = await fetch('/api/dashboard/ia-insights?tenant_id=' + encodeURIComponent(tenantId) + '&data=' + encodeURIComponent(today));
                        if (apiRes.ok) {
                            const json = await apiRes.json();
                            const d = json.data || {};
                            geralData = { geral: d.geral || '' };
                            ligacoesData = { calls: d.calls || '' };
                            conversasData = { conversas: d.conversas || '' };
                            agendamentosData = { agendamentos: d.agendamentos || '' };
                        }
                    } catch (_) {}
                    if (!geralData.geral && !ligacoesData.calls && !conversasData.conversas) {
                        try {
                            const categories = [
                                { id: 'geral', field: 'geral' },
                                { id: 'calls', field: 'calls' },
                                { id: 'conversas', field: 'conversas' },
                                { id: 'agendamentos', field: 'agendamentos' }
                            ];
                            const results = await Promise.all(categories.map(cat =>
                                fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ tenant_id: tenantId, categoria: cat.id, data_filtro: today, userData: userData })
                                }).then(r => r.json())
                            ));
                            geralData = results[0] || {};
                            ligacoesData = results[1] || {};
                            conversasData = results[2] || {};
                            agendamentosData = results[3] || {};
                        } catch (_) {}
                    }
                    if (Array.isArray(geralData) && geralData.length > 0) geralData = geralData[0];
                    if (Array.isArray(ligacoesData) && ligacoesData.length > 0) ligacoesData = ligacoesData[0];
                    if (Array.isArray(conversasData) && conversasData.length > 0) conversasData = conversasData[0];
                    if (Array.isArray(agendamentosData) && agendamentosData.length > 0) agendamentosData = agendamentosData[0];
                    function summarizeText(content, maxLength) {
                        if (!content) return 'Nenhuma informação disponível.';
                        const s = content.split(/[.!?]+/).filter(function (x) { return x.trim().length > 0; });
                        let sum = s.length ? s[0].trim() : content.substring(0, maxLength);
                        if (sum.length > maxLength) sum = sum.substring(0, maxLength) + '...';
                        else if (s.length > 1) sum += '...';
                        return sum;
                    }
                    geralText = stripEmojis(summarizeText(geralData.geral || geralData.geral_insight, 35));
                    ligacoesText = stripEmojis(summarizeText(ligacoesData.calls || ligacoesData.calls_insight, 35));
                    conversasText = stripEmojis(summarizeText(conversasData.conversas || conversasData.conversas_insight, 35));
                    agendamentosText = stripEmojis(summarizeText(agendamentosData.agendamentos || agendamentosData.agendamentos_insight, 35));
                    geralFullText = stripEmojis(geralData.geral || geralData.geral_insight || 'Nenhuma informação disponível.');
                    ligacoesFullText = stripEmojis(ligacoesData.calls || ligacoesData.calls_insight || 'Nenhuma informação disponível.');
                    conversasFullText = stripEmojis(conversasData.conversas || conversasData.conversas_insight || 'Nenhuma informação disponível.');
                    agendamentosFullText = stripEmojis(agendamentosData.agendamentos || agendamentosData.agendamentos_insight || 'Nenhuma informação disponível.');
                    if (window.__lastAgendamentos) {
                        const ag = window.__lastAgendamentos;
                        const n = ag.total || 0;
                        const label = ag.periodLabel || 'Período';
                        agendamentosText = n === 0 ? 'Nenhum agendamento no período.' : (n + ' agendamento(s) no período.');
                        let detail = label + ': ' + n + ' agendamento(s).';
                        if (ag.change != null && ag.change !== 0) {
                            detail += ' Variação: ' + (ag.change > 0 ? '+' : '') + ag.change.toFixed(1) + '% em relação ao período anterior.';
                        }
                        if (ag.list && ag.list.length > 0) {
                            const primeiros = ag.list.slice(0, 5);
                            const linhas = primeiros.map(function (a) {
                                const data = a.created_at || a.data_agendamento || a.data || '';
                                const nome = a.nome || a.nome_cliente || a.lead_nome || '';
                                const status = a.status || '';
                                return (data ? data.toString().substring(0, 10) : '') + (nome ? ' – ' + nome : '') + (status ? ' – ' + status : '');
                            }).filter(Boolean);
                            if (linhas.length) detail += '\n\n' + linhas.join('\n');
                        }
                        agendamentosFullText = detail;
                    }
                }
                
                // Ícones SVG
                const iconGeral = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>';
                const iconLigacoes = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>';
                const iconConversas = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>';
                const iconAgendamentos = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>';
                
                // Construir HTML - Geral ao lado de Ligações, depois Conversas e Agendamentos
                let widgetHTML = `
                    <div class="grazi-section-row">
                        <div class="grazi-section-item">
                            <div class="grazi-tooltip">
                                <div class="grazi-tooltip-title">${iconGeral} Geral</div>
                                <div class="grazi-tooltip-text">${geralFullText}</div>
                            </div>
                            <div class="grazi-section-header">
                                <div class="grazi-section-icon">${iconGeral}</div>
                                <div class="grazi-section-title">Geral</div>
                                <div class="grazi-section-text">${geralText}</div>
                            </div>
                        </div>
                        <div class="grazi-section-item">
                            <div class="grazi-tooltip">
                                <div class="grazi-tooltip-title">${iconLigacoes} Ligações</div>
                                <div class="grazi-tooltip-text">${ligacoesFullText}</div>
                            </div>
                            <div class="grazi-section-header">
                                <div class="grazi-section-icon">${iconLigacoes}</div>
                                <div class="grazi-section-title">Ligações</div>
                                <div class="grazi-section-text">${ligacoesText}</div>
                            </div>
                        </div>
                    </div>
                    <div class="grazi-section-row">
                        <div class="grazi-section-item">
                            <div class="grazi-tooltip">
                                <div class="grazi-tooltip-title">${iconConversas} Conversas</div>
                                <div class="grazi-tooltip-text">${conversasFullText}</div>
                            </div>
                            <div class="grazi-section-header">
                                <div class="grazi-section-icon">${iconConversas}</div>
                                <div class="grazi-section-title">Conversas</div>
                                <div class="grazi-section-text">${conversasText}</div>
                            </div>
                        </div>
                        <div class="grazi-section-item">
                            <div class="grazi-tooltip">
                                <div class="grazi-tooltip-title">${iconAgendamentos} Agendamentos</div>
                                <div class="grazi-tooltip-text">${agendamentosFullText}</div>
                            </div>
                            <div class="grazi-section-header">
                                <div class="grazi-section-icon">${iconAgendamentos}</div>
                                <div class="grazi-section-title">Agendamentos</div>
                                <div class="grazi-section-text">${agendamentosText}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                widgetContent.innerHTML = widgetHTML;

            } catch (error) {
                console.error('[Grazi Widget] Erro ao carregar:', error);
                widgetContent.innerHTML = '<div class="grazi-widget-preview" style="color: rgba(255,255,255,0.6);">Erro ao carregar dados. Tente novamente.</div>';
            }
        }

        // Função para redirecionar para ajuda.html com Insights aberto
        function redirectToGraziInsights() {
            console.log('[Dashboard] 🎯 Redirecionando para Grazi Insights em ajuda.html...');
            
            // Verificar se está em iframe (menu.html)
            if (window.parent && window.parent !== window) {
                try {
                    const parentContentFrame = window.parent.document.getElementById('contentFrame');
                    if (parentContentFrame) {
                        // Redirecionar para ajuda.html com parâmetro mode=insights
                        parentContentFrame.src = 'ajuda/ajuda.html?mode=insights';
                        return;
                    }
                } catch (e) {
                    console.warn('[Dashboard] ⚠️ Erro ao acessar contentFrame:', e);
                }
                
                // Fallback: usar postMessage
                window.parent.postMessage({
                    type: 'redirect-iframe',
                    url: 'ajuda/ajuda.html?mode=insights'
                }, '*');
            } else {
                // Se não está em iframe, redirecionar página atual
                window.location.href = '../ajuda/ajuda.html?mode=insights';
            }
        }

        async function openInsightsPopup() {
            const popup = document.getElementById('insightsPopup');
            popup.classList.add('active');
            document.body.classList.add('popup-open');

            // Inicializar timer de inatividade
            resetInactivityTimer();
            
            // Verificar se precisa criar nova sessão
            getOrCreateSessionId();
            
            // Verificar se há uma sessão existente e carregar histórico
            const existingSessionId = sessionStorage.getItem('grazi_insights_session_id');
            if (existingSessionId) {
                console.log('[Grazi Insights] 💾 Sessão existente encontrada:', existingSessionId);
                console.log('[Grazi Insights] ✅ Memória do chat será preservada');
            }

            // Adicionar listener no input para resetar timer ao digitar
            const chatInput = document.getElementById('insightsChatInput');
            if (chatInput) {
                chatInput.addEventListener('input', () => {
                    resetInactivityTimer();
                });
                chatInput.addEventListener('keypress', () => {
                    resetInactivityTimer();
                });
            }

            // Limpar histórico inválido ao abrir
            cleanAllChatHistory();
            
            // Carregar conversas recentes
            loadRecentConversations();
            
            // Tentar carregar conversa atual (se existir)
            const hasCurrentChat = loadCurrentChat();
            
            // Se não tem conversa atual, mostrar mensagem de boas-vindas
            if (!hasCurrentChat) {
                const messagesContainer = document.getElementById('insightsChatMessages');
                if (messagesContainer && messagesContainer.children.length === 0) {
                    addChatMessageNew('ai', 'Olá! 👋 Sou a **Grazi AI**, a Inteligência Artificial da SalesDever!\n\nEstou aqui para te ajudar com tudo na plataforma. Como posso te ajudar hoje?', true);
                }
            }
        }
        
        function closeInsightsPopup() {
            // Salvar chat atual antes de fechar
            saveCurrentChat();

            const popup = document.getElementById('insightsPopup');
            popup.classList.remove('active');
            document.body.classList.remove('popup-open');
            
            // Limpar timer de inatividade ao fechar
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
            
            // Salvar chat atual antes de fechar (se tiver 10+ interações)
            const userData = JSON.parse(localStorage.getItem('userData') || '{}');
            const tenantId = userData.user?.tenant_id || userData.tenant_id;
            const userId = userData.user?.id || userData.id || 'default';
            const currentSessionId = sessionStorage.getItem('grazi_insights_session_id');
            
            if (currentSessionId) {
                const tempChatKey = `grazi_chat_temp_${tenantId}_${userId}_${currentSessionId}`;
                const currentChat = JSON.parse(sessionStorage.getItem(tempChatKey) || '{}');
                
                // Se o chat atual tem 10+ interações, salvar antes de fechar
                if (currentChat.interactions && currentChat.interactions.length >= 10) {
                    saveCompleteChatToHistory(currentChat);
                }
            }
        }
        
        // Função para validar se uma interação é válida
        function isValidInteraction(userMessage, aiResponse) {
            // Verificar se ambas as mensagens existem e não estão vazias
            if (!userMessage || !aiResponse) return false;
            
            const userMsg = String(userMessage).trim();
            const aiMsg = String(aiResponse).trim();
            
            // Mensagem do usuário deve ter pelo menos 2 caracteres
            if (userMsg.length < 2) return false;
            
            // Resposta da IA deve ter pelo menos 10 caracteres (respostas muito curtas são provavelmente erros)
            if (aiMsg.length < 10) return false;
            
            // Não salvar se a resposta for apenas mensagem de erro genérica
            const errorPatterns = [
                'não consegui processar',
                'erro ao processar',
                'resposta vazia',
                'tente novamente'
            ];
            
            const lowerResponse = aiMsg.toLowerCase();
            if (errorPatterns.some(pattern => lowerResponse.includes(pattern) && aiMsg.length < 50)) {
                return false; // Provavelmente é um erro, não salvar
            }
            
            return true;
        }

        // Função para salvar interação no chat atual (temporário)
        function saveInteractionToCurrentChat(userMessage, aiResponse) {
            try {
                // Validar interação antes de salvar
                if (!isValidInteraction(userMessage, aiResponse)) {
                    console.log('[Grazi Chat] Interação inválida, não será salva');
                    return;
                }
                
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                const sessionId = sessionStorage.getItem('grazi_insights_session_id');
                
                if (!sessionId) {
                    console.warn('[Grazi Chat] SessionId não encontrado');
                    return;
                }
                
                const tempChatKey = `grazi_chat_temp_${tenantId}_${userId}_${sessionId}`;
                let currentChat = JSON.parse(sessionStorage.getItem(tempChatKey) || '{}');
                
                // Inicializar chat se não existir
                if (!currentChat.sessionId) {
                    currentChat = {
                        sessionId: sessionId,
                        createdAt: new Date().toISOString(),
                        interactions: []
                    };
                    console.log('[Grazi Chat] Novo chat temporário criado:', sessionId);
                }
                
                // Adicionar nova interação
                const interaction = {
                    id: Date.now(),
                    userMessage: String(userMessage).trim(),
                    aiResponse: String(aiResponse).trim(),
                    timestamp: new Date().toISOString()
                };
                
                currentChat.interactions.push(interaction);
                
                console.log(`[Grazi Chat] ✅ Interação válida salva. Total: ${currentChat.interactions.length}`);
                
                // Salvar chat temporário
                sessionStorage.setItem(tempChatKey, JSON.stringify(currentChat));
                
            } catch (error) {
                console.error('[Grazi Chat] Erro ao salvar interação:', error);
            }
        }
        
        // Função para limpar todo o histórico do usuário
        function cleanAllChatHistory() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                
                if (!tenantId) return;
                
                const storageKey = `grazi_chat_history_${tenantId}_${userId}`;
                let history = JSON.parse(localStorage.getItem(storageKey) || '[]');
                
                const beforeCount = history.length;
                history = cleanChatHistory(history);
                const afterCount = history.length;
                
                if (beforeCount !== afterCount) {
                    if (history.length > 0) {
                        localStorage.setItem(storageKey, JSON.stringify(history));
                    } else {
                        localStorage.removeItem(storageKey);
                    }
                    console.log(`[Grazi Chat] Histórico limpo: ${beforeCount} → ${afterCount} chats válidos`);
                }
            } catch (error) {
                console.error('[Grazi Chat] Erro ao limpar histórico:', error);
            }
        }

        // Função para limpar e validar histórico de conversas
        function cleanChatHistory(history) {
            if (!Array.isArray(history)) return [];
            
            return history
                .filter(chat => {
                    // Remover chats sem sessionId
                    if (!chat.sessionId) return false;
                    
                    // Remover chats sem interações
                    if (!chat.interactions || !Array.isArray(chat.interactions)) return false;
                    
                    // Remover chats com menos de 1 interação válida
                    const validInteractions = chat.interactions.filter(interaction => 
                        isValidInteraction(interaction.userMessage, interaction.aiResponse)
                    );
                    
                    if (validInteractions.length === 0) return false;
                    
                    // Atualizar contagem de interações válidas
                    chat.interactions = validInteractions;
                    chat.interactionsCount = validInteractions.length;
                    
                    return true;
                })
                .map(chat => {
                    // Garantir que tem preview válido
                    if (!chat.preview || chat.preview === 'Nova conversa') {
                        const firstValid = chat.interactions.find(i => i.userMessage);
                        chat.preview = firstValid 
                            ? (firstValid.userMessage.length > 60 
                                ? firstValid.userMessage.substring(0, 60) + '...' 
                                : firstValid.userMessage)
                            : 'Conversa';
                    }
                    
                    // Garantir que tem data e hora
                    if (!chat.date || !chat.time) {
                        const timestamp = chat.createdAt || chat.lastUpdated || Date.now();
                        const date = new Date(timestamp);
                        chat.date = date.toLocaleDateString('pt-BR');
                        chat.time = date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    }
                    
                    return chat;
                });
        }

        // Função para salvar chat no histórico permanente
        function saveChatToHistory(chatData) {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                
                if (!chatData || !chatData.interactions || !Array.isArray(chatData.interactions)) {
                    console.warn('[Grazi Chat] Chat inválido, não será salvo');
                    return;
                }
                
                // Filtrar apenas interações válidas
                const validInteractions = chatData.interactions.filter(interaction => 
                    isValidInteraction(interaction.userMessage, interaction.aiResponse)
                );
                
                // Só salvar se tiver pelo menos 1 interação válida
                if (validInteractions.length === 0) {
                    console.warn('[Grazi Chat] Chat não tem interações válidas, não será salvo');
                    return;
                }
                
                const storageKey = `grazi_chat_history_${tenantId}_${userId}`;
                let history = JSON.parse(localStorage.getItem(storageKey) || '[]');
                
                // Limpar histórico antes de adicionar novo
                history = cleanChatHistory(history);
                
                // Criar preview do chat (primeira mensagem válida do usuário)
                const firstValidInteraction = validInteractions.find(i => i.userMessage);
                if (!firstValidInteraction) {
                    console.error('[Grazi Chat] Nenhuma interação válida encontrada');
                    return;
                }
                
                const preview = firstValidInteraction.userMessage.length > 60 
                    ? firstValidInteraction.userMessage.substring(0, 60) + '...' 
                    : firstValidInteraction.userMessage;
                
                // Criar objeto do chat
                const chatToSave = {
                    sessionId: chatData.sessionId,
                    createdAt: chatData.createdAt || new Date().toISOString(),
                    lastUpdated: Date.now(),
                    interactionsCount: validInteractions.length,
                    preview: preview,
                    interactions: validInteractions,
                    date: new Date(chatData.createdAt || Date.now()).toLocaleDateString('pt-BR'),
                    time: new Date(chatData.createdAt || Date.now()).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })
                };
                
                // Verificar se já existe um chat com esse sessionId
                const existingIndex = history.findIndex(chat => chat.sessionId === chatData.sessionId);
                
                if (existingIndex >= 0) {
                    // Atualizar chat existente
                    history[existingIndex] = chatToSave;
                    console.log('[Grazi Chat] Chat atualizado no histórico');
                } else {
                    // Adicionar novo chat no início
                    history.unshift(chatToSave);
                    console.log('[Grazi Chat] Novo chat adicionado ao histórico');
                }
                
                // Limpar novamente e ordenar por último atualizado
                history = cleanChatHistory(history);
                history.sort((a, b) => (b.lastUpdated || 0) - (a.lastUpdated || 0));
                
                // Manter apenas os últimos 50 chats
                if (history.length > 50) {
                    history = history.slice(0, 50);
                }
                
                localStorage.setItem(storageKey, JSON.stringify(history));
                console.log(`[Grazi Chat] ✅ Chat salvo com ${validInteractions.length} interações válidas`);
                console.log('[Grazi Chat] Histórico limpo:', history.length, 'chats válidos');
                
                // Atualizar lista de conversas recentes
                setTimeout(() => {
                    loadRecentConversations();
                }, 200);
                
            } catch (error) {
                console.error('[Grazi Chat] Erro ao salvar chat:', error);
            }
        }
        
        // Função para criar novo chat
        function createNewChat() {
            // Salvar chat atual antes de criar novo
            saveCurrentChat();
            
            // Limpar mensagens atuais
            const messagesContainer = document.getElementById('insightsChatMessages');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
            
            // Limpar histórico da sessão
            graziChatHistory = [];
            
            // Criar nova sessão
            createNewSession();
            
            // Recarregar lista de conversas
            loadRecentConversations();
            
            console.log('[Grazi Chat] Novo chat criado');
        }

        // Função para salvar chat atual no histórico permanente
        function saveCurrentChat() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                const sessionId = sessionStorage.getItem('grazi_insights_session_id');
                
                if (!sessionId) {
                    return; // Não salvar se não tem sessão
                }
                
                const tempChatKey = `grazi_chat_temp_${tenantId}_${userId}_${sessionId}`;
                const currentChat = JSON.parse(sessionStorage.getItem(tempChatKey) || '{}');
                
                if (!currentChat.interactions || !Array.isArray(currentChat.interactions)) {
                    return; // Não salvar se não tem interações
                }
                
                // Filtrar apenas interações válidas
                const validInteractions = currentChat.interactions.filter(interaction => 
                    isValidInteraction(interaction.userMessage, interaction.aiResponse)
                );
                
                // Só salvar se tiver pelo menos 1 interação válida
                if (validInteractions.length === 0) {
                    console.log('[Grazi Chat] Chat atual não tem interações válidas, não será salvo');
                    return;
                }
                
                // Usar a função de salvar no histórico
                const chatDataToSave = {
                    sessionId: sessionId,
                    createdAt: currentChat.createdAt || new Date().toISOString(),
                    interactions: validInteractions
                };
                
                saveChatToHistory(chatDataToSave);
                
            } catch (error) {
                console.error('[Grazi Chat] Erro ao salvar chat atual:', error);
            }
        }

        // Função para carregar conversa atual ao abrir popup
        function loadCurrentChat() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                const sessionId = sessionStorage.getItem('grazi_insights_session_id');
                
                if (!sessionId) {
                    return false; // Não tem sessão
                }
                
                const tempChatKey = `grazi_chat_temp_${tenantId}_${userId}_${sessionId}`;
                const currentChat = JSON.parse(sessionStorage.getItem(tempChatKey) || '{}');
                
                if (!currentChat.interactions || !Array.isArray(currentChat.interactions)) {
                    return false; // Não tem interações salvas
                }
                
                // Filtrar apenas interações válidas
                const validInteractions = currentChat.interactions.filter(interaction => 
                    isValidInteraction(interaction.userMessage, interaction.aiResponse)
                );
                
                if (validInteractions.length === 0) {
                    return false; // Não tem interações válidas
                }
                
                const messagesContainer = document.getElementById('insightsChatMessages');
                if (!messagesContainer) return false;
                
                // Limpar mensagens atuais
                messagesContainer.innerHTML = '';
                
                // Restaurar histórico
                graziChatHistory = [];
                
                // Carregar apenas interações válidas
                validInteractions.forEach(interaction => {
                    addChatMessageNew('user', interaction.userMessage, false);
                    addChatMessageNew('ai', interaction.aiResponse, false);
                    
                    // Restaurar histórico para API
                    graziChatHistory.push({ role: 'user', content: interaction.userMessage });
                    graziChatHistory.push({ role: 'assistant', content: interaction.aiResponse });
                });
                
                // Atualizar chat temporário com apenas interações válidas
                if (validInteractions.length < currentChat.interactions.length) {
                    currentChat.interactions = validInteractions;
                    sessionStorage.setItem(tempChatKey, JSON.stringify(currentChat));
                }
                
                // Scroll para o final
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
                
                console.log('[Grazi Chat] Conversa atual restaurada:', validInteractions.length, 'interações válidas');
                return true; // Conversa carregada com sucesso
                
            } catch (error) {
                console.error('[Grazi Chat] Erro ao carregar conversa atual:', error);
                return false;
            }
        }

        // Função para carregar e exibir chats completos recentes
        function loadRecentConversations() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                
                const storageKey = `grazi_chat_history_${tenantId}_${userId}`;
                let history = JSON.parse(localStorage.getItem(storageKey) || '[]');
                
                console.log('[Grazi Chat] Carregando histórico. Total antes da limpeza:', history.length);
                
                // Limpar e validar histórico
                history = cleanChatHistory(history);
                
                // Salvar histórico limpo de volta
                if (history.length > 0) {
                    localStorage.setItem(storageKey, JSON.stringify(history));
                } else {
                    localStorage.removeItem(storageKey);
                }
                
                console.log('[Grazi Chat] Histórico após limpeza:', history.length, 'chats válidos');
                
                const listContainer = document.getElementById('recentConversationsList');
                if (!listContainer) {
                    console.warn('[Grazi Chat] Container de conversas não encontrado');
                    return;
                }
                
                // Ordenar por último atualizado (mais recente primeiro)
                const sortedHistory = history.sort((a, b) => (b.lastUpdated || 0) - (a.lastUpdated || 0));
                
                if (sortedHistory.length === 0) {
                    listContainer.innerHTML = '<div class="sidebar-empty-state">Nenhuma conversa ainda<br><small style="font-size: 0.7rem; opacity: 0.6;">Suas conversas aparecerão aqui</small></div>';
                    return;
                }
                
                listContainer.innerHTML = '';
                
                sortedHistory.forEach(chat => {
                    const item = document.createElement('div');
                    item.className = 'sidebar-conversation-item';
                    
                    const currentSessionId = sessionStorage.getItem('grazi_insights_session_id');
                    if (chat.sessionId === currentSessionId) {
                        item.classList.add('active');
                    }
                    
                    item.onclick = () => {
                        // Salvar chat atual antes de trocar
                        saveCurrentChat();
                        
                        // Carregar chat selecionado
                        loadChatIntoPanel(chat);
                        
                        // Atualizar sessão atual
                        sessionStorage.setItem('grazi_insights_session_id', chat.sessionId);
                        
                        // Atualizar lista para destacar ativo
                        loadRecentConversations();
                    };
                    
                    const interactionsCount = chat.interactionsCount || (chat.interactions ? chat.interactions.length : 0);
                    
                    item.innerHTML = `
                        <div class="sidebar-conversation-preview">${chat.preview || 'Conversa'}</div>
                        <div class="sidebar-conversation-time">${chat.date || ''} às ${chat.time || ''} • ${interactionsCount} interação${interactionsCount !== 1 ? 'ões' : ''}</div>
                    `;
                    
                    listContainer.appendChild(item);
                });
                
                console.log('[Grazi Chat] ✅ Lista de conversas atualizada');
                
            } catch (error) {
                console.error('[Grazi Chat] Erro ao carregar conversas:', error);
            }
        }
        
        // Função para carregar um chat completo no painel principal
        function loadChatIntoPanel(chat) {
            const messagesContainer = document.getElementById('insightsChatMessages');
            if (!messagesContainer || !chat.interactions) return;
            
            // Limpar mensagens atuais
            messagesContainer.innerHTML = '';
            
            // Limpar histórico atual
            graziChatHistory = [];
            
            // Adicionar todas as interações do chat
            chat.interactions.forEach(interaction => {
                // Mensagem do usuário
                addChatMessageNew('user', interaction.userMessage, false);
                // Resposta da IA
                addChatMessageNew('ai', interaction.aiResponse, false);
                
                // Restaurar histórico para API
                graziChatHistory.push({ role: 'user', content: interaction.userMessage });
                graziChatHistory.push({ role: 'assistant', content: interaction.aiResponse });
            });
            
            // Scroll para o final
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
            
            console.log('[Grazi Chat] Chat carregado:', chat.interactions.length, 'interações');
        }
        
        // Função para fazer pergunta rápida
        async function askQuickQuestion(question) {
            const input = document.getElementById('insightsChatInput');
            if (input) {
                input.value = question;
                input.focus();
                // Resetar timer de inatividade
                resetInactivityTimer();
                // Enviar automaticamente após um pequeno delay
                setTimeout(() => {
                    sendChatMessage();
                }, 100);
            }
        }
        
        // Função de debug para verificar estado do chat
        function debugChatState() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const userId = userData.user?.id || userData.id || 'default';
                const sessionId = sessionStorage.getItem('grazi_insights_session_id');
                
                console.log('=== DEBUG CHAT STATE ===');
                console.log('SessionId:', sessionId);
                console.log('TenantId:', tenantId);
                console.log('UserId:', userId);
                
                if (sessionId) {
                    const tempChatKey = `grazi_chat_temp_${tenantId}_${userId}_${sessionId}`;
                    const tempChat = JSON.parse(sessionStorage.getItem(tempChatKey) || '{}');
                    console.log('Chat temporário:', tempChat);
                    console.log('Interações no chat temporário:', tempChat.interactions ? tempChat.interactions.length : 0);
                }
                
                const storageKey = `grazi_chat_history_${tenantId}_${userId}`;
                const history = JSON.parse(localStorage.getItem(storageKey) || '[]');
                console.log('Histórico completo:', history);
                console.log('Total de chats no histórico:', history.length);
                
                const completeChats = history.filter(chat => {
                    const count = chat.interactionsCount || (chat.interactions ? chat.interactions.length : 0);
                    return count >= 10;
                });
                console.log('Chats completos (10+ interações):', completeChats.length);
                console.log('========================');
            } catch (error) {
                console.error('[Debug] Erro:', error);
            }
        }
        
        // Expor função de debug globalmente
        window.debugChatState = debugChatState;
        
        // Função para carregar insights e exibir como mensagens de chat
        async function loadGraziInsightsToChat() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    addChatMessageNew('ai', 'Erro: Tenant ID não encontrado', false);
                    return;
                }

                // Data de hoje
                const today = new Date().toISOString().split('T')[0];

                const categories = [
                    { id: 'geral', field: 'geral', title: 'Geral' },
                    { id: 'calls', field: 'calls', title: 'Ligações' },
                    { id: 'conversas', field: 'conversas', title: 'Conversas' },
                    { id: 'agendamentos', field: 'agendamentos', title: 'Agendamentos' }
                ];

                // Mostrar loading
                const loadingId = addChatMessageNew('ai', '<div class="loading-dots"><span></span><span></span><span></span></div>', false, true);

                let results = [];
                // 1) Tentar API local (tabela ia_insights) – dados reais do tenant
                try {
                    const apiRes = await fetch('/api/dashboard/ia-insights?tenant_id=' + encodeURIComponent(tenantId) + '&data=' + encodeURIComponent(today));
                    if (apiRes.ok) {
                        const json = await apiRes.json();
                        const d = json.data || {};
                        if (d.geral || d.calls || d.conversas || d.agendamentos) {
                            results = [
                                { geral: d.geral || '' },   // Geral = coluna geral (como n8n resumo)
                                { calls: d.calls || '' },
                                { conversas: d.conversas || '' },
                                { agendamentos: d.agendamentos || '' }
                            ];
                        }
                    }
                } catch (e) { /* fallback abaixo */ }
                // 2) Se não veio da API local, buscar do webhook
                if (results.length === 0) {
                    const promises = categories.map(cat =>
                        fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                tenant_id: tenantId,
                                categoria: cat.id,
                                data_filtro: today,
                                userData: userData
                            })
                        }).then(res => res.json())
                    );
                    results = await Promise.all(promises);
                }

                // Remover loading
                const loadingMsg = document.getElementById(loadingId);
                if (loadingMsg) loadingMsg.remove();

                // Processar e exibir cada categoria como mensagem
                results.forEach((data, index) => {
                    const cat = categories[index];
                    let actualData = data;
                    if (Array.isArray(data) && data.length > 0) {
                        actualData = data[0];
                    }

                    const content = actualData[cat.field] || `Nenhuma informação disponível para ${cat.title.toLowerCase()}.`;
                    
                    // Exibir como mensagem da IA com título da categoria
                    const message = `**${cat.title}**\n\n${content}`;
                    addChatMessageNew('ai', message, false);
                });

            } catch (error) {
                console.error('[Grazi Chat] Erro ao carregar insights:', error);
                addChatMessageNew('ai', 'Erro ao carregar insights. Tente novamente.', false);
            }
        }
        
        // Função para adicionar mensagem ao chat (nova versão estilo ChatGPT/Claude)
        function addChatMessageNew(type, content, isWelcome = false, isLoading = false) {
            const messagesContainer = document.getElementById('insightsChatMessages');
            const messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            messageDiv.id = messageId;
            
            if (type === 'ai') {
                messageDiv.innerHTML = `
                    <div class="chat-message-ai-header">
                        <img src="https://gwjcgzeybqiyqezuswpt.supabase.co/storage/v1/object/public/profile-pictures/GRAZI.png" alt="Grazi" class="chat-avatar-ai">
                        <div class="chat-sender-name">Grazi A.I</div>
                    </div>
                    <div class="chat-bubble ai ${isLoading ? 'loading' : ''}">
                        ${isLoading ? content : formatChatMessage(content)}
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="chat-sender-name">Você</div>
                    <div class="chat-bubble user">${content}</div>
                `;
            }
            
            messagesContainer.appendChild(messageDiv);
            
            // Scroll para o final
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
            
            return messageId;
        }
        
        // Função para dividir texto em blocos inteligentes
        // Função para dividir texto em blocos inteligentes (estilo WhatsApp)
        // Baseada em lógica Python para divisão natural de mensagens
        function splitTextIntoBlocks(text, maxChars = 100) {
            /**
             * Divide um texto longo em mensagens menores que façam sentido.
             * 
             * Exemplo:
             * Input: "Oi, tudo bem? Aqui é a GRAZI da Sales Dever. Em que posso te ajudar hoje?"
             * Output: ["Oi, tudo bem?", "Aqui é a GRAZI da Sales Dever.", "Em que posso te ajudar hoje?"]
             */
            
            // Se o texto já é pequeno, retorna direto
            if (text.length <= maxChars) {
                return [text.trim()];
            }
            
            const mensagens = [];
            
            // 1. Primeiro divide por quebras de linha (se tiver)
            const partes = text.split('\n').map(p => p.trim()).filter(p => p);
            
            for (const parte of partes) {
                // 2. Divide por pontuação final (. ! ?)
                const sentencas = parte.split(/(?<=[.!?])\s+/);
                
                let mensagemAtual = "";
                
                for (let sentenca of sentencas) {
                    sentenca = sentenca.trim();
                    if (!sentenca) {
                        continue;
                    }
                    
                    // Se a sentença sozinha já é grande demais, divide por vírgula
                    if (sentenca.length > maxChars) {
                        if (mensagemAtual) {
                            mensagens.push(mensagemAtual.trim());
                            mensagemAtual = "";
                        }
                        
                        // Divide por vírgula ou outros separadores
                        const subPartes = sentenca.split(/(?<=[,;:])\s+/);
                        
                        for (const sub of subPartes) {
                            if (mensagemAtual.length + sub.length <= maxChars) {
                                mensagemAtual += (mensagemAtual ? " " : "") + sub;
                            } else {
                                if (mensagemAtual) {
                                    mensagens.push(mensagemAtual.trim());
                                }
                                mensagemAtual = sub;
                            }
                        }
                    }
                    // Se cabe na mensagem atual, adiciona
                    else if (mensagemAtual.length + sentenca.length + 1 <= maxChars) {
                        mensagemAtual += (mensagemAtual ? " " : "") + sentenca;
                    }
                    // Se não cabe, salva a atual e começa nova
                    else {
                        if (mensagemAtual) {
                            mensagens.push(mensagemAtual.trim());
                        }
                        mensagemAtual = sentenca;
                    }
                }
                
                // Não esquece a última mensagem
                if (mensagemAtual) {
                    mensagens.push(mensagemAtual.trim());
                }
            }
            
            // Se não dividiu nada, retorna o texto original
            return mensagens.length > 0 ? mensagens : [text.trim()];
        }
        
        // Função para destacar partes importantes em roxo
        function highlightImportantParts(text) {
            if (!text) return '';
            
            let highlighted = text;
            
            // Destacar números (métricas, valores)
            // Padrão: números com ou sem decimais, possivelmente seguidos de %, R$, etc.
            highlighted = highlighted.replace(/(\d+[\d.,]*\s*(?:%|R\$|reais?|minutos?|horas?|dias?|ligações?|chamadas?|conversas?|mensagens?|contatos?|assistentes?|campanhas?|webhooks?|leads?|agendamentos?|sucessos?|tentativas?|conexões?|conversões?|taxa|taxas?))/gi, '<span class="highlight-purple">$1</span>');
            
            // Destacar valores monetários (R$ X,XX)
            highlighted = highlighted.replace(/(R\$\s*\d+[\d.,]*)/gi, '<span class="highlight-purple">$1</span>');
            
            // Destacar porcentagens
            highlighted = highlighted.replace(/(\d+[\d.,]*%)/gi, '<span class="highlight-purple">$1</span>');
            
            // Destacar palavras-chave importantes (após destacar números para evitar duplicação)
            const keywords = [
                'taxa de sucesso', 'taxa de conversão', 'taxa de conexão',
                'total de ligações', 'total de chamadas', 'total de conversas',
                'total de mensagens', 'total de contatos', 'total de assistentes',
                'duração média', 'custo total', 'minutos usados',
                'conversas ativas', 'mensagens hoje', 'ligações hoje',
                'campanhas ativas', 'campanhas pausadas', 'campanhas finalizadas',
                'assistentes ativos', 'assistentes inativos'
            ];
            
            keywords.forEach(keyword => {
                const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                highlighted = highlighted.replace(regex, '<span class="highlight-purple">$1</span>');
            });
            
            return highlighted;
        }
        
        // Função para formatar mensagem (markdown básico) com divisão em blocos e destaque em roxo
        function formatChatMessage(text) {
            if (!text) return '';
            
            // Primeiro destacar partes importantes
            text = highlightImportantParts(text);
            
            // Converter **texto** para <strong>
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Dividir em blocos se necessário (estilo WhatsApp - mensagens menores e naturais)
            const blocks = splitTextIntoBlocks(text, 100);
            
            // Se tem apenas um bloco, retornar formatado normalmente
            if (blocks.length === 1) {
                return blocks[0].replace(/\n/g, '<br>');
            }
            
            // Se tem múltiplos blocos, juntar com espaçamento
            return blocks.map(block => block.replace(/\n/g, '<br>')).join('<br><br>');
        }
        
        // Função para aplicar efeito de digitação durante streaming
        let typingState = {
            currentText: '',
            targetText: '',
            bubbleEl: null,
            typingInterval: null,
            lastUpdateTime: 0
        };
        
        function updateTypingEffect(newText, bubbleElement) {
            if (!bubbleElement) return;
            
            typingState.targetText = newText;
            typingState.bubbleEl = bubbleElement;
            
            // Se não há intervalo ativo, iniciar
            if (!typingState.typingInterval) {
                typingState.typingInterval = setInterval(() => {
                    const now = Date.now();
                    // Limitar atualizações a cada 20ms para suavizar
                    if (now - typingState.lastUpdateTime < 20) return;
                    typingState.lastUpdateTime = now;
                    
                    if (typingState.currentText.length < typingState.targetText.length) {
                        // Adicionar próximo caractere
                        const nextChar = typingState.targetText[typingState.currentText.length];
                        typingState.currentText += nextChar;
                        
                        // Formatar e atualizar
                        const formatted = formatChatMessage(typingState.currentText);
                        if (typingState.bubbleEl) {
                            typingState.bubbleEl.innerHTML = formatted;
                            
                            // Scroll automático
                            const messagesContainer = document.getElementById('insightsChatMessages');
                            if (messagesContainer) {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }
                        }
                    } else {
                        // Finalizar digitação
                        clearInterval(typingState.typingInterval);
                        typingState.typingInterval = null;
                        // Garantir que o texto final está completo e formatado
                        const finalFormatted = formatChatMessage(typingState.targetText);
                        if (typingState.bubbleEl) {
                            typingState.bubbleEl.innerHTML = finalFormatted;
                        }
                    }
                }, 15); // 15ms por caractere = ~67 caracteres por segundo
            }
        }
        
        function resetTypingState() {
            if (typingState.typingInterval) {
                clearInterval(typingState.typingInterval);
                typingState.typingInterval = null;
            }
            typingState.currentText = '';
            typingState.targetText = '';
            typingState.bubbleEl = null;
            typingState.lastUpdateTime = 0;
        }

        // Verificar se insights foram vistos ao carregar a página
        async function checkInsightsViewed() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    return;
                }

                const response = await fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        userData: userData
                    })
                });

                if (!response.ok) {
                    return;
                }

                const data = await response.json();
                console.log('📢 Status de visualização (raw):', data);

                // Se data é um array, pegar o primeiro item
                let actualData = data;
                if (Array.isArray(data) && data.length > 0) {
                    actualData = data[0];
                    console.log('📢 É array, usando primeiro item:', actualData);
                }

                // Se visto é false, mostrar badge
                if (actualData.visto === false || actualData.visto === 'false') {
                    console.log('✅ Mostrando badge de notificação - insights não vistos');
                    const badge = document.getElementById('insightsNotificationBadge');
                    if (badge) {
                        badge.classList.remove('hidden');
                    }
                } else {
                    console.log('ℹ️ Insights já foram vistos, badge permanece oculto');
                }

            } catch (error) {
                console.error('Erro ao verificar insights vistos:', error);
            }
        }

        // Marcar insights como vistos
        async function markInsightsAsViewed() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    return;
                }

                const response = await fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos_visto', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        visto: true,
                        userData: userData
                    })
                });

                if (response.ok) {
                    console.log('Insights marcados como vistos');
                    // Esconder badge
                    const badge = document.getElementById('insightsNotificationBadge');
                    if (badge) {
                        badge.classList.add('hidden');
                    }
                }

            } catch (error) {
                console.error('Erro ao marcar insights como vistos:', error);
            }
        }

        // Chamar verificação ao carregar a página
        document.addEventListener('DOMContentLoaded', function() {
            // Garantir que tooltip não apareça no sistema principal
            const path = window.location.pathname;
            const href = window.location.href;
            const isDemo = path.includes('onboarding-tutorial-demo') || 
                          href.includes('onboarding-tutorial-demo') ||
                          (window.parent && window.parent !== window && 
                           (window.parent.location.pathname.includes('onboarding-tutorial-demo-menu') ||
                            window.parent.location.href.includes('onboarding-tutorial-demo-menu')));
            
            if (!isDemo) {
                // Sistema principal - garantir que tooltip está oculto
                const overlay = document.getElementById('welcomeTooltipOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.visibility = 'hidden';
                    console.log('[Dashboard] ✅ Tooltip de boas-vindas oculto no sistema principal (DOMContentLoaded)');
                }
            }
            
            // Carregar widget da Grazi
            loadGraziWidgetSummary();
            checkInsightsViewed();
            updateMinutesUsed();
            
            // Verificar se deve abrir Grazi Insights automaticamente (vindo da página de ajuda)
            const shouldOpenInsights = sessionStorage.getItem('open_grazi_insights_on_load') === 'true';
            if (shouldOpenInsights) {
                console.log('[Dashboard] 🎯 Abrindo Grazi Insights automaticamente (solicitado da página de ajuda)...');
                sessionStorage.removeItem('open_grazi_insights_on_load');
                
                // Aguardar um pouco para garantir que tudo carregou
                setTimeout(() => {
                    if (typeof openInsightsPopup === 'function') {
                        openInsightsPopup();
                        console.log('[Dashboard] ✅ Grazi Insights aberta com memória preservada');
                    } else {
                        console.warn('[Dashboard] ⚠️ openInsightsPopup não disponível ainda, tentando novamente...');
                        setTimeout(() => {
                            if (typeof openInsightsPopup === 'function') {
                                openInsightsPopup();
                            }
                        }, 500);
                    }
                }, 800);
            }

            // Atualiza os minutos a cada 5 segundos (caso seja atualizado por outro processo)
            setInterval(updateMinutesUsed, 5000);
        });

        // Função para atualizar minutos usados
        async function updateMinutesUsed() {
            try {
                console.log('═══════════════════════════════════════════════════════════');
                console.log('🔄 INICIANDO updateMinutesUsed()');
                console.log('═══════════════════════════════════════════════════════════');

                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    console.error('❌ Tenant ID não encontrado');
                    return;
                }

                // Chamar webhook para buscar minutos atualizados
                const response = await fetch('https://sdr.salesdever.io/webhook/ver-minutos-saas', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tenant_id: tenantId
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erro HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('📡 Resposta do webhook ver-minutos-saas:', data);

                // Extrair dados (pode ser array ou objeto direto)
                const minutesData = Array.isArray(data) ? data[0] : data;

                const minutesMax = parseFloat(minutesData.minutes_max || 0);
                const minutesPlan = parseFloat(minutesData.minutes_plan || 500);

                console.log('📊 Minutos máximos:', minutesMax);
                console.log('📊 Plano de minutos:', minutesPlan);

                // Atualizar no DOM
                const minutesElement = document.getElementById('minutesUsed');
                if (minutesElement) {
                    minutesElement.textContent = `${minutesMax.toFixed(2)} / ${minutesPlan}`;
                    console.log('✅ Display atualizado:', `${minutesMax.toFixed(2)} / ${minutesPlan}`);
                }

                // Salvar no localStorage para referência
                localStorage.setItem('minutes_max', String(minutesMax));
                localStorage.setItem('minutes_plan', String(minutesPlan));

            } catch (error) {
                console.error('❌ Erro ao atualizar minutos usados:', error);
                const minutesElement = document.getElementById('minutesUsed');
                if (minutesElement) {
                    minutesElement.textContent = '0.00 / 500';
                }
            }
        }

        // Fechar popup ao pressionar ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeInsightsPopup();
            }
        });

        // Funcao para fazer perguntas
        async function askInsight(question) {
            console.log('Pergunta enviada:', question);

            // Marcar como visto ao interagir
            markInsightsAsViewed();

            // Adicionar mensagem do usuario ao chat
            addChatMessage(question, 'user');

            // Adicionar loading
            const loadingId = addChatLoading();

            try {
                // Buscar dados do localStorage
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    throw new Error('Tenant ID não encontrado');
                }

                // Chamar webhook
                const response = await fetch('https://sdr.salesdever.io/webhook/ia_Insights', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        question: question,
                        userData: userData
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erro HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('Resposta da IA:', data);

                // Remover loading
                removeChatLoading(loadingId);

                // Extrair a resposta correta do webhook
                let answer = '';

                // Verificar se tem a propriedade "output" primeiro
                if (data.output) {
                    answer = data.output;
                }
                // Verificar se tem a propriedade "resposta" (quando não tem dados de hoje)
                else if (data.resposta) {
                    answer = data.resposta;
                }
                // Verificar qual tipo de pergunta e extrair a resposta correspondente
                else if (data.objeção || data['objeção']) {
                    answer = data.objeção || data['objeção'];
                }
                else if (data.conversas) {
                    answer = data.conversas;
                }
                else if (data.ligações || data['ligações']) {
                    answer = data.ligações || data['ligações'];
                }
                else if (data.agendamentos) {
                    answer = data.agendamentos;
                }
                else if (data.resumo) {
                    answer = data.resumo;
                }
                else {
                    // Fallback: tentar pegar qualquer propriedade que não seja metadata
                    const keys = Object.keys(data).filter(key => !['tenant_id', 'id', 'criado_dia'].includes(key));
                    answer = keys.length > 0 ? data[keys[0]] : 'Desculpe, não consegui processar sua pergunta.';
                }

                addChatMessage(answer, 'ai');

            } catch (error) {
                console.error('Erro ao buscar insight:', error);
                removeChatLoading(loadingId);
                addChatMessage('Desculpe, ocorreu um erro ao processar sua pergunta. Tente novamente.', 'ai');
            }
        }

        // Variável para controlar última atividade
        let lastActivityTime = Date.now();
        let inactivityTimer = null;
        const INACTIVITY_TIMEOUT = 60 * 60 * 1000; // 1 hora em milissegundos
        
        // Grazi: nosso frontend (popup/sidebar/chat + cards do widget). Backend = Edge Function grazi-chat.
        const GRAZI_EDGE_CONFIG = {
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3amNnemV5YnFpeXFlenVzd3B0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0NTYwMDgsImV4cCI6MjA3NjAzMjAwOH0.vAXY2hibMpBZofIziY2dKHi1ZICFLaupuD1IhtJU7x4',
            EDGE_FUNCTION_URL: 'https://gwjcgzeybqiyqezuswpt.supabase.co/functions/v1/grazi-chat'
        };
        window.GRAZI_EDGE_CONFIG = GRAZI_EDGE_CONFIG;
        let graziChatHistory = []; // History para a Edge Function (últimas trocas user/assistant)
        
        // Função para resetar timer de inatividade
        function resetInactivityTimer() {
            lastActivityTime = Date.now();
            
            // Limpar timer anterior
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            // Criar novo timer
            inactivityTimer = setTimeout(() => {
                // Após 1 hora de inatividade, criar nova sessão
                console.log('[Grazi Chat] 1 hora de inatividade detectada - criando nova sessão');
                createNewSession();
            }, INACTIVITY_TIMEOUT);
        }
        
        // Função para criar nova sessão
        function createNewSession() {
            // Salvar chat atual antes de criar nova sessão (se tiver interações)
            const userData = JSON.parse(localStorage.getItem('userData') || '{}');
            const tenantId = userData.user?.tenant_id || userData.tenant_id;
            const userId = userData.user?.id || userData.id || 'default';
            const currentSessionId = sessionStorage.getItem('grazi_insights_session_id');
            
            if (currentSessionId) {
                const tempChatKey = `grazi_chat_temp_${tenantId}_${userId}_${currentSessionId}`;
                const currentChat = JSON.parse(sessionStorage.getItem(tempChatKey) || '{}');
                
                // Se o chat atual tem 10+ interações, salvar antes de criar nova sessão
                if (currentChat.interactions && currentChat.interactions.length >= 10) {
                    saveCompleteChatToHistory(currentChat);
                }
                
                // Limpar chat temporário
                sessionStorage.removeItem(tempChatKey);
            }
            
            // Limpar session_id atual
            sessionStorage.removeItem('grazi_insights_session_id');
            
            // Gerar novo session_id
            const newSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('grazi_insights_session_id', newSessionId);
            
            // Salvar timestamp da nova sessão
            sessionStorage.setItem('grazi_insights_session_created', Date.now().toString());
            
            graziChatHistory = [];
            console.log('[Grazi Chat] Nova sessão criada:', newSessionId);
        }
        
        // Funcao para gerar ou recuperar session_id
        function getOrCreateSessionId() {
            // Verificar se já existe uma sessão
            let sessionId = sessionStorage.getItem('grazi_insights_session_id');
            const sessionCreated = sessionStorage.getItem('grazi_insights_session_created');
            
            // Se não existe sessão ou passou mais de 1 hora desde a criação
            if (!sessionId || !sessionCreated) {
                createNewSession();
                sessionId = sessionStorage.getItem('grazi_insights_session_id');
            } else {
                // Verificar se passou mais de 1 hora desde a última atividade
                const timeSinceLastActivity = Date.now() - lastActivityTime;
                if (timeSinceLastActivity >= INACTIVITY_TIMEOUT) {
                    createNewSession();
                    sessionId = sessionStorage.getItem('grazi_insights_session_id');
                }
            }
            
            // Resetar timer de inatividade
            resetInactivityTimer();
            
            return sessionId;
        }

        // Funcao para enviar mensagem customizada do chat (Edge Function grazi-chat - substitui n8n)
        async function sendChatMessage() {
            const input = document.getElementById('insightsChatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Resetar timer de inatividade ao enviar mensagem
            resetInactivityTimer();
            
            // Limpar input
            input.value = '';
            
            // Adicionar mensagem do usuário
            addChatMessageNew('user', message);
            
            // History para a Edge Function (últimas 10 trocas; a mensagem atual vai em "message")
            const historyForApi = graziChatHistory.slice(-10);
            graziChatHistory.push({ role: 'user', content: message });
            
            // Mostrar loading
            const loadingId = addChatMessageNew('ai', '<div class="loading-dots"><span></span><span></span><span></span></div>', false, true);
            
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;
                const sessionId = getOrCreateSessionId();
                
                console.log('[Grazi Chat] Enviando mensagem:', { message, tenantId, sessionId, historyLength: historyForApi.length });
                
                if (!tenantId) {
                    throw new Error('Tenant ID não encontrado no localStorage');
                }
                
                // Coletar contexto do frontend
                let frontendContext = null;
                if (window.GraziFrontendCollector) {
                    try {
                        frontendContext = window.GraziFrontendCollector.collect();
                        console.log('[Grazi Dashboard] Frontend context coletado:', frontendContext.pagina);
                    } catch (e) {
                        console.warn('[Grazi Dashboard] Erro ao coletar frontend:', e);
                    }
                }
                
                const response = await fetch(GRAZI_EDGE_CONFIG.EDGE_FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${GRAZI_EDGE_CONFIG.SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        message: message,
                        tenant_id: tenantId,
                        session_id: sessionId,
                        history: historyForApi,
                        chat_mode: 'insights', // Dashboard sempre usa modo insights (análise de dados)
                        frontend_context: frontendContext
                    })
                });
                
                console.log('[Grazi Chat] Resposta recebida:', { status: response.status, statusText: response.statusText, headers: Object.fromEntries(response.headers.entries()) });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[Grazi Chat] Erro HTTP:', { status: response.status, body: errorText });
                    throw new Error(`Erro HTTP: ${response.status} - ${errorText}`);
                }
                
                // Verificar se é streaming ou JSON normal
                const contentType = response.headers.get('content-type') || '';
                console.log('[Grazi Chat] Content-Type:', contentType);
                
                // Processar streaming SSE (contrato da Edge Function grazi-chat)
                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let respostaCompleta = '';
                let bubbleEl = null;
                let buffer = '';
                let chunkCount = 0;
                
                // Remover loading
                document.getElementById(loadingId)?.remove();
                
                // Resetar estado de digitação
                resetTypingState();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        console.log('[Grazi Chat] Stream finalizado. Total de chunks:', chunkCount, 'Resposta completa length:', respostaCompleta.length, 'Buffer final:', buffer);
                        break;
                    }
                    
                    chunkCount++;
                    const decodedChunk = decoder.decode(value, { stream: true });
                    console.log(`[Grazi Chat] Chunk ${chunkCount} recebido (${decodedChunk.length} bytes):`, decodedChunk.substring(0, 200));
                    buffer += decodedChunk;
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        const t = line.trim();
                        if (!t) continue;
                        
                        console.log('[Grazi Chat] Processando linha:', t.substring(0, 100));
                        
                        // Tentar diferentes formatos de SSE
                        let data = null;
                        if (t.startsWith('data: ')) {
                            data = t.slice(6);
                        } else if (t.startsWith('{')) {
                            // Pode ser JSON direto sem prefixo "data: "
                            data = t;
                        } else if (t.startsWith('event:') || t.startsWith('id:') || t.startsWith('retry:')) {
                            // Linhas de metadados SSE, ignorar
                            continue;
                        } else {
                            console.log('[Grazi Chat] Linha ignorada (formato desconhecido):', t.substring(0, 50));
                            continue;
                        }
                        
                        if (data === '[DONE]') {
                            console.log('[Grazi Chat] Recebido [DONE]');
                            continue;
                        }
                        
                        try {
                            const parsed = JSON.parse(data);
                            console.log('[Grazi Chat] Chunk parsed:', parsed);
                            
                            if (parsed.content) {
                                respostaCompleta += parsed.content;
                                if (!bubbleEl) {
                                    // Primeira vez - criar mensagem vazia para iniciar digitação
                                    const msgId = addChatMessageNew('ai', '', false);
                                    bubbleEl = document.getElementById(msgId)?.querySelector('.chat-bubble');
                                    if (bubbleEl) {
                                        bubbleEl.innerHTML = '';
                                    }
                                }
                                
                                // Atualizar com efeito de digitação
                                if (bubbleEl) {
                                    updateTypingEffect(respostaCompleta, bubbleEl);
                                }
                            }
                            
                            if (parsed.session_id) {
                                sessionStorage.setItem('grazi_insights_session_id', parsed.session_id);
                            }
                            
                            // Se a resposta vier completa (não streaming)
                            if (parsed.response && !parsed.content) {
                                respostaCompleta = parsed.response;
                                if (!bubbleEl) {
                                    const msgId = addChatMessageNew('ai', '', false);
                                    bubbleEl = document.getElementById(msgId)?.querySelector('.chat-bubble');
                                    if (bubbleEl) {
                                        bubbleEl.innerHTML = '';
                                    }
                                }
                                // Aplicar efeito de digitação mesmo para resposta completa
                                if (bubbleEl) {
                                    updateTypingEffect(respostaCompleta, bubbleEl);
                                }
                            }
                            
                            // Se houver erro na resposta
                            if (parsed.error) {
                                console.error('[Grazi Chat] Erro na resposta:', parsed.error);
                                throw new Error(parsed.error);
                            }
                        } catch (e) {
                            console.warn('[Grazi Chat] Erro ao parsear chunk:', e, 'Data:', data?.substring(0, 100));
                            // Tentar tratar como texto puro se não for JSON
                            if (data && !data.startsWith('{') && !data.startsWith('[')) {
                                console.log('[Grazi Chat] Tratando como texto puro:', data);
                                respostaCompleta += data;
                                if (!bubbleEl) {
                                    const msgId = addChatMessageNew('ai', '', false);
                                    bubbleEl = document.getElementById(msgId)?.querySelector('.chat-bubble');
                                    if (bubbleEl) {
                                        bubbleEl.innerHTML = '';
                                    }
                                }
                                // Aplicar efeito de digitação
                                if (bubbleEl) {
                                    updateTypingEffect(respostaCompleta, bubbleEl);
                                }
                            }
                        }
                    }
                }
                
                // Garantir que a digitação termine completamente
                if (typingState.typingInterval) {
                    // Aguardar um pouco para garantir que a digitação termine
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                if (respostaCompleta) {
                    graziChatHistory.push({ role: 'assistant', content: respostaCompleta });
                    saveInteractionToCurrentChat(message, respostaCompleta);
                    saveCurrentChat(); // Salvar chat atual após cada interação
                    console.log('[Grazi Chat] Mensagem processada com sucesso');
                } else {
                    console.error('[Grazi Chat] Resposta vazia recebida. Possíveis causas:');
                    console.error('1. OPENAI_API_KEY não configurada no Supabase');
                    console.error('2. Edge Function não está retornando dados');
                    console.error('3. Problema de conexão com OpenAI');
                    
                    const errorMsg = '⚠️ A Edge Function retornou uma resposta vazia. Isso geralmente indica que a OPENAI_API_KEY não está configurada no Supabase. Por favor, configure a variável de ambiente OPENAI_API_KEY nas Secrets da Edge Function.';
                    addChatMessageNew('ai', errorMsg, false);
                    saveInteractionToCurrentChat(message, errorMsg);
                }
                
            } catch (error) {
                console.error('[Grazi Chat] Erro ao enviar mensagem:', error);
                const loadingMsg = document.getElementById(loadingId);
                if (loadingMsg) loadingMsg.remove();
                const errorMsg = `Erro ao processar sua mensagem: ${error.message}. Verifique o console para mais detalhes.`;
                addChatMessageNew('ai', errorMsg, false);
                saveInteractionToCurrentChat(message, errorMsg);
            }
        }
        
        async function sendChatMessageOld() {
            const inputElement = document.getElementById('insightsChatInput');
            const message = inputElement.value.trim();

            if (!message) {
                return;
            }

            // Limpar input
            inputElement.value = '';

            // Adicionar mensagem do usuario ao chat
            addChatMessage(message, 'user');

            // Adicionar loading
            const loadingId = addChatLoading();

            try {
                // Buscar dados do localStorage
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    throw new Error('Tenant ID não encontrado');
                }

                // Obter ou criar session_id
                const sessionId = getOrCreateSessionId();

                // Chamar webhook do chat
                const response = await fetch('https://sdr.salesdever.io/webhook/0bef1a76-01b5-4806-81f3-72cd4a0c74f5/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        message: message,
                        session_id: sessionId,
                        userData: userData
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erro HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('Resposta do chat:', data);

                // Remover loading
                removeChatLoading(loadingId);

                // Extrair a resposta do webhook
                let answer = '';

                // Verificar se tem a propriedade "output" primeiro
                if (data.output) {
                    answer = data.output;
                } else if (data.response) {
                    answer = data.response;
                } else if (data.message) {
                    answer = data.message;
                } else if (data.resposta) {
                    answer = data.resposta;
                } else if (typeof data === 'string') {
                    answer = data;
                } else {
                    answer = 'Desculpe, não consegui processar sua mensagem.';
                }

                addChatMessage(answer, 'ai');

            } catch (error) {
                console.error('Erro ao enviar mensagem:', error);
                removeChatLoading(loadingId);
                addChatMessage('Desculpe, ocorreu um erro ao processar sua mensagem. Tente novamente.', 'ai');
            }
        }

        // Funcao para obter nome do usuario do email
        function getUserName() {
            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const email = userData.user?.email || userData.email || 'Usuario';
                // Pega a parte antes do @
                const username = email.split('@')[0];
                // Capitaliza primeira letra
                return username.charAt(0).toUpperCase() + username.slice(1);
            } catch (error) {
                return 'Usuario';
            }
        }

        // Adicionar mensagem ao chat
        function addChatMessage(text, type) {
            const messagesContainer = document.getElementById('insightsChatMessages');
            const senderName = type === 'ai' ? 'Grazi' : getUserName();

            // Formatar o texto para quebrar em parágrafos
            const formattedText = text.replace(/\n\n/g, '<br><br>').replace(/\n/g, '<br>');

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            messageDiv.innerHTML = `
                <div class="chat-sender-name">${senderName}</div>
                <div class="chat-bubble ${type}">
                    ${formattedText}
                </div>
            `;

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Adicionar loading ao chat
        function addChatLoading() {
            const messagesContainer = document.getElementById('insightsChatMessages');
            const loadingId = 'loading-' + Date.now();

            const loadingDiv = document.createElement('div');
            loadingDiv.id = loadingId;
            loadingDiv.className = 'chat-message ai';
            loadingDiv.innerHTML = `
                <div class="chat-sender-name">Grazi</div>
                <div class="chat-bubble ai loading">
                    <div class="loading-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;

            messagesContainer.appendChild(loadingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            return loadingId;
        }

        // Remover loading do chat
        function removeChatLoading(loadingId) {
            const loadingElement = document.getElementById(loadingId);
            if (loadingElement) {
                loadingElement.remove();
            }
        }

        // Funcao para mostrar popup customizado
        function showCustomAlert(message, title = 'Insights') {
            const overlay = document.getElementById('customAlertOverlay');
            const titleEl = document.getElementById('customAlertTitle');
            const messageEl = document.getElementById('customAlertMessage');

            titleEl.innerHTML = `
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="12" y1="16" x2="12" y2="12"/>
                    <line x1="12" y1="8" x2="12.01" y2="8"/>
                </svg>
                ${title}
            `;
            messageEl.textContent = message;
            overlay.classList.add('show');
        }

        function closeCustomAlert() {
            const overlay = document.getElementById('customAlertOverlay');
            overlay.classList.remove('show');
        }

        // Carregar datas disponíveis ao abrir o popup
        async function loadAvailableDates() {
            console.log('📅 Carregando datas disponíveis...');

            const userData = JSON.parse(localStorage.getItem('userData') || '{}');
            const tenantId = userData.user?.tenant_id || userData.tenant_id;

            if (!tenantId) {
                console.error('Tenant ID não encontrado');
                return;
            }

            try {
                // Fazer UMA requisição pedindo TODAS as datas disponíveis
                const response = await fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        categoria: 'geral',
                        list_all_dates: true,  // Flag para listar TODAS as datas
                        userData: userData
                    })
                });

                const data = await response.json();
                console.log('📊 ==================== WEBHOOK RESPONSE ====================');
                console.log('📊 Resposta completa:', JSON.stringify(data, null, 2));
                console.log('📊 É array?:', Array.isArray(data));
                console.log('📊 Quantidade de itens:', Array.isArray(data) ? data.length : 'N/A');

                // Extrair TODAS as datas únicas de múltiplas formas possíveis
                const allDates = new Set();

                // PRIORIDADE 1: Array de objetos direto (formato atual do webhook)
                if (Array.isArray(data)) {
                    console.log('✅ É UM ARRAY! Processando', data.length, 'itens...');
                    data.forEach((item, index) => {
                        console.log(`  Item ${index + 1}:`, item);
                        if (item.criado_dia) {
                            allDates.add(item.criado_dia);
                            console.log(`  ✅ Data ${index + 1} adicionada:`, item.criado_dia);
                        } else {
                            console.log(`  ❌ Item ${index + 1} NÃO tem campo criado_dia`);
                        }
                    });
                }
                // Formato 2: Array direto de datas (string array)
                else if (Array.isArray(data.available_dates)) {
                    console.log('✅ Processando data.available_dates');
                    data.available_dates.forEach(d => allDates.add(d));
                }
                // Formato 3: Objeto com results
                else if (data.results && Array.isArray(data.results)) {
                    console.log('✅ Processando data.results');
                    data.results.forEach(item => {
                        if (item.criado_dia) allDates.add(item.criado_dia);
                    });
                }
                // Formato 4: Data única (fallback)
                else if (data.criado_dia) {
                    console.log('✅ Processando data única');
                    allDates.add(data.criado_dia);
                }

                const datesArray = Array.from(allDates);
                console.log('📅 ==================== RESULTADO FINAL ====================');
                console.log('📅 Total de datas únicas encontradas:', datesArray.length);
                console.log('📅 Datas extraídas:', datesArray);
                console.log('📅 ==========================================================');

                if (datesArray.length > 0) {
                    displayDateButtons(datesArray);
                } else {
                    document.getElementById('calendarContainer').innerHTML = '<div class="date-loading">Nenhuma data disponível</div>';
                }

            } catch (error) {
                console.error('❌ Erro ao carregar datas:', error);
                document.getElementById('calendarContainer').innerHTML = '<div class="date-loading">Erro ao carregar datas</div>';
            }
        }

        // Variáveis globais do calendário
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();
        let availableDates = [];
        let selectedDate = null;

        // Renderizar calendário
        function renderCalendar() {
            console.log('🎨 ==================== RENDERIZANDO CALENDÁRIO ====================');
            console.log('🎨 availableDates array:', availableDates);
            console.log('🎨 Quantidade de datas disponíveis:', availableDates.length);

            const container = document.getElementById('calendarContainer');
            const monthLabel = document.getElementById('calendarMonthLabel');

            // Nome do mês
            const monthNames = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
                'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
            monthLabel.textContent = `${monthNames[currentMonth]} ${currentYear}`;

            // Grid do calendário
            let html = '<div class="calendar-grid">';

            // Dias da semana
            const weekdays = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
            weekdays.forEach(day => {
                html += `<div class="calendar-weekday">${day}</div>`;
            });

            // Primeiro dia do mês e total de dias
            const firstDay = new Date(currentYear, currentMonth, 1).getDay();
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            const today = new Date();

            console.log(`🎨 Renderizando ${daysInMonth} dias para ${monthNames[currentMonth]} ${currentYear}`);

            // Espaços vazios antes do primeiro dia
            for (let i = 0; i < firstDay; i++) {
                html += '<div class="calendar-day empty"></div>';
            }

            let daysWithDataCount = 0;

            // Dias do mês
            for (let day = 1; day <= daysInMonth; day++) {
                const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const hasData = availableDates.some(d => d.startsWith(dateStr));

                if (hasData) {
                    daysWithDataCount++;
                    console.log(`  ✅ Dia ${day} (${dateStr}) TEM DADOS`);
                }

                const isToday = today.getDate() === day && today.getMonth() === currentMonth && today.getFullYear() === currentYear;
                const isSelected = selectedDate && selectedDate.startsWith(dateStr);

                let classes = 'calendar-day';
                if (hasData) classes += ' available';
                if (isToday) classes += ' today';
                if (isSelected) classes += ' active';

                const onclick = hasData ? `onclick="selectCalendarDate('${dateStr}')"` : '';

                html += `<div class="${classes}" ${onclick}>${day}</div>`;
            }

            html += '</div>';
            container.innerHTML = html;

            console.log(`🎨 Total de dias com dados no calendário: ${daysWithDataCount}`);
            console.log('🎨 ================================================================');
        }

        // Mudar mês
        function changeMonth(delta) {
            currentMonth += delta;
            if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            } else if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
            renderCalendar();
        }

        // Selecionar data do calendário
        function selectCalendarDate(dateStr) {
            // Encontrar a data completa (com timestamp)
            const fullDate = availableDates.find(d => d.startsWith(dateStr));
            if (fullDate) {
                selectedDate = fullDate;
                updateCurrentDateDisplay(fullDate);
                renderCalendar();
                loadInsightsByDate(fullDate);
                // Fechar calendário dropdown após seleção
                document.getElementById('calendarWrapper').classList.remove('show');
            }
        }

        // Toggle de mostrar/esconder calendário (dropdown flutuante)
        function toggleCalendar() {
            const wrapper = document.getElementById('calendarWrapper');
            wrapper.classList.toggle('show');
        }

        // Atualizar display da data atual
        function updateCurrentDateDisplay(dateStr) {
            const date = new Date(dateStr);
            const day = date.getDate();
            const monthNames = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
                'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();

            const label = document.getElementById('currentDateLabel');
            if (label) {
                label.textContent = `Dia ${String(day).padStart(2, '0')}, ${month} ${year}`;
            }
        }

        // Exibir calendário com datas disponíveis
        function displayDateButtons(dates) {
            availableDates = [...new Set(dates)].sort().reverse();

            // Pegar o mês/ano da data mais recente
            if (availableDates.length > 0) {
                const mostRecent = new Date(availableDates[0]);
                currentMonth = mostRecent.getMonth();
                currentYear = mostRecent.getFullYear();
                selectedDate = availableDates[0];

                // Atualizar display da data atual
                updateCurrentDateDisplay(availableDates[0]);
            }

            renderCalendar();

            // Carregar insights da primeira data
            if (availableDates.length > 0) {
                loadInsightsByDate(availableDates[0]);
            }
        }

        // Carregar insights de uma data específica
        async function loadInsightsByDate(selectedDate) {
            console.log('📊 Carregando insights da data:', selectedDate);

            // Marcar como visto
            markInsightsAsViewed();

            const userData = JSON.parse(localStorage.getItem('userData') || '{}');
            const tenantId = userData.user?.tenant_id || userData.tenant_id;

            if (!tenantId) {
                console.error('Tenant ID não encontrado');
                return;
            }

            const categories = [
                { id: 'geral', field: 'geral' },
                { id: 'conversas', field: 'conversas' },
                { id: 'calls', field: 'calls' },
                { id: 'agendamentos', field: 'agendamentos' }
            ];

            // Mostrar loading em todas as seções
            categories.forEach(cat => {
                const contentDiv = document.getElementById(`content-${cat.id}`);
                contentDiv.innerHTML = 'Carregando...';
            });
            document.getElementById('content-consideracoes').innerHTML = 'Carregando...';

            // 1) Dados da tabela ia_insights (Geral, Ligações, Conversas, Agendamentos). Agendamentos no card usa total do dashboard.
            let apiConsideracoes = null;
            try {
                let results = [];
                const apiRes = await fetch('/api/dashboard/ia-insights?tenant_id=' + encodeURIComponent(tenantId) + '&data=' + encodeURIComponent(selectedDate));
                if (apiRes.ok) {
                    const json = await apiRes.json();
                    const d = json.data || {};
                    if (d.geral || d.calls || d.conversas || d.agendamentos) {
                        results = [
                            { geral: d.geral || '' },
                            { conversas: d.conversas || '' },
                            { calls: d.calls || '' },
                            { agendamentos: d.agendamentos || '' }
                        ];
                        if (d.consideracoes) apiConsideracoes = d.consideracoes;
                    }
                }
                if (results.length === 0) {
                    const promises = categories.map(cat =>
                        fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                tenant_id: tenantId,
                                categoria: cat.id,
                                data_filtro: selectedDate,
                                userData: userData
                            })
                        }).then(res => res.json())
                    );
                    results = await Promise.all(promises);
                }

                console.log('📊 Resultados das requisições:', results);

                let sharedDate = '';

                // Preencher cada seção
                results.forEach((data, index) => {
                    const cat = categories[index];

                    console.log(`📊 Processando categoria ${cat.id}:`, data);

                    // Se data é um array, pegar o primeiro item
                    let actualData = data;
                    if (Array.isArray(data) && data.length > 0) {
                        actualData = data[0];
                        console.log(`  ⚠️ Resposta é array, pegando primeiro item:`, actualData);
                    }

                    const content = actualData[cat.field] || 'Nenhuma informação disponível.';

                    // Pegar a data (todas devem ser iguais)
                    if (!sharedDate && actualData.criado_dia) {
                        sharedDate = formatInsightDate(actualData.criado_dia);
                    }

                    console.log(`  ✅ Conteúdo para ${cat.id}:`, content.substring(0, 100) + '...');
                    document.getElementById(`content-${cat.id}`).textContent = content;
                });

                // Preencher considerações finais (API local retorna consideracoes; webhook retorna no primeiro item)
                let consideracoes = apiConsideracoes;
                if (consideracoes == null) {
                    let firstResult = results[0];
                    if (Array.isArray(firstResult) && firstResult.length > 0) {
                        firstResult = firstResult[0];
                    }
                    consideracoes = firstResult?.consideracoes_finais || firstResult?.consideracoes || 'Nenhuma consideração adicional.';
                }
                document.getElementById('content-consideracoes').textContent = consideracoes;

                // Adicionar data no rodapé - usar a data selecionada
                const footerDate = formatInsightDate(selectedDate);
                if (footerDate) {
                    document.getElementById('insightDateFooter').textContent = `Gerado em: ${footerDate}`;
                }

            } catch (error) {
                console.error('Erro ao carregar insights:', error);
                categories.forEach(cat => {
                    document.getElementById(`content-${cat.id}`).textContent = 'Erro ao carregar. Tente novamente.';
                });
                document.getElementById('content-consideracoes').textContent = 'Erro ao carregar.';
            }
        }

        function formatInsightDate(criadoDia) {
            if (!criadoDia) return '';
            const dataParts = criadoDia.split('T')[0];
            const [ano, mes, dia] = dataParts.split('-');
            return `${dia}/${mes}/${ano}`;
        }

        // Funcao para abrir categoria de insight
        async function openInsightCategory(category) {
            console.log('Categoria selecionada:', category);

            // Marcar como visto ao interagir
            markInsightsAsViewed();

            try {
                const userData = JSON.parse(localStorage.getItem('userData') || '{}');
                const tenantId = userData.user?.tenant_id || userData.tenant_id;

                if (!tenantId) {
                    showCustomAlert('Erro: Tenant ID não encontrado', 'Erro');
                    return;
                }

                // Mapear categorias para os campos corretos retornados pelo webhook
                const categoryMap = {
                    'Geral': 'geral',
                    'Conversas': 'conversas',
                    'Ligações': 'calls',
                    'Agendamentos': 'agendamentos'
                };

                const categoryField = categoryMap[category];

                const response = await fetch('https://sdr.salesdever.io/webhook/ia_Insights_infos', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tenant_id: tenantId,
                        categoria: categoryField,
                        userData: userData
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erro HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('Resposta do webhook:', data);

                // Extrair apenas a data (sem horário)
                let dataFormatada = '';
                const criadoDia = data.criado_dia || data.data || '';
                if (criadoDia) {
                    const dataParts = criadoDia.split('T')[0]; // Pega apenas YYYY-MM-DD
                    const [ano, mes, dia] = dataParts.split('-');
                    dataFormatada = `${dia}/${mes}/${ano}`;
                }

                // Buscar o campo correto baseado no que foi clicado
                let info = '';
                if (category === 'Geral' && data.geral) {
                    info = data.geral;
                } else if (category === 'Conversas' && data.conversas) {
                    info = data.conversas;
                } else if (category === 'Ligações' && data.calls) {
                    info = data.calls;
                } else if (category === 'Agendamentos' && data.agendamentos) {
                    info = data.agendamentos;
                } else {
                    info = 'Nenhuma informação disponível para esta categoria.';
                }

                // Montar título com data ao lado
                const titulo = dataFormatada ? `Insights - ${category}: ${dataFormatada}` : `Insights - ${category}`;

                showCustomAlert(info, titulo);

            } catch (error) {
                console.error('Erro ao buscar insights:', error);
                showCustomAlert('Erro ao carregar insights. Tente novamente.', 'Erro');
            }
        }
    </script>

    <!-- POPUP IA INSIGHTS -->
    <div id="insightsPopup" class="insights-popup">
        <div class="insights-popup-overlay" onclick="closeInsightsPopup()"></div>

        <div class="insights-popup-content">
            <!-- Header com botao fechar -->
            <div class="insights-popup-header">
                <div class="insights-header-title">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                        <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                    </svg>
                    <h2><span class="grazi-name">Grazi</span> <span class="grazi-ai-badge-popup">A.I</span></h2>
                </div>
                <div class="insights-header-actions">
                    <button class="insights-new-chat-btn" onclick="createNewChat()" title="Nova conversa">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        Novo Chat
                    </button>
                    <button class="insights-close-btn" onclick="closeInsightsPopup()">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Container principal - CHAT ESTILO ChatGPT/Claude -->
            <div class="insights-main-container-chat">
                <!-- Sidebar com conversas passadas (esquerda) -->
                <div class="insights-chat-sidebar">
                    <div class="sidebar-header">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                        </svg>
                        <span>Conversas</span>
                    </div>
                    <div class="sidebar-conversations-list" id="recentConversationsList">
                        <!-- Conversas serão adicionadas aqui -->
                    </div>
                </div>

                <!-- Chat Grazi - Estilo ChatGPT/Claude (centro) -->
                <div class="insights-chat-section-full">
                    <!-- Container do chat com mensagens e input -->
                    <div class="insights-chat-container-full">
                        <div class="insights-chat-messages" id="insightsChatMessages">
                            <!-- Mensagens serão adicionadas aqui dinamicamente -->
                        </div>

                        <!-- Input para enviar mensagens -->
                        <div class="insights-chat-input-container">
                            <input
                                type="text"
                                id="insightsChatInput"
                                class="insights-chat-input"
                                placeholder="Digite sua mensagem..."
                                onkeypress="if(event.key === 'Enter') sendChatMessage()"
                            />
                            <button class="insights-chat-send-btn" onclick="sendChatMessage()">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="22" y1="2" x2="11" y2="13"/>
                                    <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Sidebar com Perguntas Rápidas (direita) -->
                <div class="insights-quick-questions-sidebar">
                    <div class="quick-questions-sidebar-header">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#A594FF" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        <span>Perguntas Rápidas</span>
                    </div>
                    <div class="quick-questions-sidebar-list">
                        <button class="quick-question-sidebar-btn" onclick="askQuickQuestion('Qual a principal objeção de hoje?')">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                <line x1="12" y1="17" x2="12.01" y2="17"/>
                            </svg>
                            Qual a principal objeção de hoje?
                        </button>
                        <button class="quick-question-sidebar-btn" onclick="askQuickQuestion('Quantas conversas foram iniciadas hoje?')">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            </svg>
                            Quantas conversas foram iniciadas hoje?
                        </button>
                        <button class="quick-question-sidebar-btn" onclick="askQuickQuestion('Quantas ligações foram feitas hoje?')">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                            </svg>
                            Quantas ligações foram feitas hoje?
                        </button>
                        <button class="quick-question-sidebar-btn" onclick="askQuickQuestion('Tivemos quantos agendamentos hoje?')">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                                <line x1="16" y1="2" x2="16" y2="6"/>
                                <line x1="8" y1="2" x2="8" y2="6"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                            </svg>
                            Tivemos quantos agendamentos hoje?
                        </button>
                        <button class="quick-question-sidebar-btn" onclick="askQuickQuestion('Qual o resumo de hoje?')">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                            </svg>
                            Qual o resumo de hoje?
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- POPUP CUSTOMIZADO DE ALERTA -->
    <div id="customAlertOverlay" class="custom-alert-overlay" onclick="closeCustomAlert()">
        <div class="custom-alert-box" onclick="event.stopPropagation()">
            <div class="custom-alert-title" id="customAlertTitle">Informacao</div>
            <div class="custom-alert-message" id="customAlertMessage">Mensagem</div>
            <button class="custom-alert-btn" onclick="closeCustomAlert()">Entendi</button>
        </div>
    </div>

    <!-- Script para remover código JavaScript que apareça como texto no DOM -->
    <script>
        (function() {
            // Remover qualquer texto que contenha código JavaScript visível
            function removeVisibleJavaScript() {
                // Procurar por nós de texto que contenham código JavaScript
                const walker = document.createTreeWalker(
                    document.body,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let node;
                const toRemove = [];
                
                while (node = walker.nextNode()) {
                    const text = node.textContent.trim();
                    // Se o texto começa com "// DESBLOQUEAR" ou contém "function unlockScroll", remover
                    if (text.startsWith('// DESBLOQUEAR') || text.includes('function unlockScroll')) {
                        toRemove.push(node);
                    }
                }
                
                // Remover os nós encontrados
                toRemove.forEach(n => {
                    if (n.parentNode) {
                        n.parentNode.removeChild(n);
                    }
                });
            }
            
            // Executar quando o DOM estiver pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', removeVisibleJavaScript);
            } else {
                removeVisibleJavaScript();
            }
            
            // Executar periodicamente para pegar código inserido dinamicamente
            setInterval(removeVisibleJavaScript, 1000);
        })();
    </script>
    
    <!-- Script de Inicialização Forçada do Tutorial -->
    <script>
        // Forçar limpeza de flags e garantir que botões sejam criados
        (function() {
            console.log('[Dashboard Init] ========================================');
            console.log('[Dashboard Init] Inicializando sistema de tutorial no dashboard...');
            
            // Limpar TODAS as flags bloqueantes
            localStorage.removeItem('onboarding_disabled');
            localStorage.removeItem('onboarding_auto_show_disabled');
            localStorage.setItem('onboarding_reactivated', 'true');
            console.log('[Dashboard Init] Flags bloqueantes limpas!');
            
            // Verificar se scripts carregaram e forçar criação dos botões
            setTimeout(() => {
                console.log('[Dashboard Init] Verificando scripts...');
                console.log('[Dashboard Init] tutorial-button.js carregado?', typeof createTutorialButton !== 'undefined');
                
                // Forçar criação do botão de tutorial se não existir
                const tutorialBtn = document.getElementById('tutorial-button');
                if (!tutorialBtn) {
                    console.log('[Dashboard Init] ⚠️ Botão de tutorial não encontrado - forçando criação...');
                    if (typeof createTutorialButton === 'function') {
                        createTutorialButton();
                    } else {
                        console.error('[Dashboard Init] ❌ createTutorialButton não está disponível!');
                        // Tentar novamente após mais tempo
                        setTimeout(() => {
                            if (typeof createTutorialButton === 'function') {
                                createTutorialButton();
                            }
                        }, 500);
                    }
                } else {
                    console.log('[Dashboard Init] ✅ Botão de tutorial encontrado!');
                }
                
                console.log('[Dashboard Init] ========================================');
            }, 500);
        })();
    </script>
    
    <!-- Script para garantir que tooltip NÃO apareça no sistema principal -->
    <script>
        (function() {
            // Verificar se é sistema principal
            const path = window.location.pathname;
            const href = window.location.href;
            const isDemo = path.includes('onboarding-tutorial-demo') || 
                          href.includes('onboarding-tutorial-demo') ||
                          (window.parent && window.parent !== window && 
                           (window.parent.location.pathname.includes('onboarding-tutorial-demo-menu') ||
                            window.parent.location.href.includes('onboarding-tutorial-demo-menu')));
            
            if (!isDemo) {
                console.log('[Dashboard] ⚠️ Sistema principal detectado - garantindo que tooltip não apareça...');
                
                // Função para forçar ocultação do tooltip
                function forceHideTooltip() {
                    const overlay = document.getElementById('welcomeTooltipOverlay');
                    if (overlay) {
                        overlay.style.display = 'none';
                        overlay.style.visibility = 'hidden';
                        overlay.style.opacity = '0';
                        overlay.style.pointerEvents = 'none';
                    }
                }
                
                // Forçar ocultação imediatamente
                forceHideTooltip();
                
                // Monitorar e forçar ocultação periodicamente (caso algo tente exibir)
                setInterval(forceHideTooltip, 500);
                
                // Observar mudanças no overlay
                const overlay = document.getElementById('welcomeTooltipOverlay');
                if (overlay) {
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                                const display = overlay.style.display;
                                if (display === 'flex' || display === 'block') {
                                    console.log('[Dashboard] ⚠️ Tentativa de exibir tooltip bloqueada!');
                                    forceHideTooltip();
                                }
                            }
                        });
                    });
                    
                    observer.observe(overlay, {
                        attributes: true,
                        attributeFilter: ['style']
                    });
                }
            }
        })();
    </script>

    <!-- Grazi Frontend Collector -->
    <script src="../js/grazi-frontend-collector.js"></script>
    <!-- Widget Flutuante Grazi AI -->
    <script src="../js/grazi-embed-widget.js"></script>
</body>
</html>